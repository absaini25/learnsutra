"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[2737],{3779:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>o,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Designing Nested Comments/index","title":"Building a Scalable Model for Nested Comments","description":"Nested comments are a core feature in many applications, from social media platforms like Reddit and Facebook to content management systems. Designing a scalable database model to handle these comments efficiently is crucial. This post explores various approaches, their challenges, and trade-offs when implementing nested comments.","source":"@site/system-design/Designing Nested Comments/index.md","sourceDirName":"Designing Nested Comments","slug":"/Designing Nested Comments/","permalink":"/system-design/Designing Nested Comments/","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/edit/main/system-design/Designing Nested Comments/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"Distributed locking via Redis","permalink":"/system-design/Distributed Systems Nuances/distributed-locking"}}');var r=s(4848),l=s(8453);const t={},d="Building a Scalable Model for Nested Comments",a={},c=[{value:"<strong>Part 1: Core Challenges of Nested Comments</strong>",id:"part-1-core-challenges-of-nested-comments",level:3},{value:"<strong>What Makes Nested Comments Difficult?</strong>",id:"what-makes-nested-comments-difficult",level:4},{value:"<strong>Goals of a Good Design</strong>",id:"goals-of-a-good-design",level:4},{value:"<strong>Part 2: Database Models for Nested Comments</strong>",id:"part-2-database-models-for-nested-comments",level:3},{value:"<strong>1. Adjacency List Model</strong>",id:"1-adjacency-list-model",level:4},{value:"<strong>2. Nested Set Model</strong>",id:"2-nested-set-model",level:4},{value:"<strong>3. Path Enumeration Model</strong>",id:"3-path-enumeration-model",level:4},{value:"<strong>4. Materialized Path with DFS Index</strong>",id:"4-materialized-path-with-dfs-index",level:4},{value:"<strong>Part 3: Queries for Each Model</strong>",id:"part-3-queries-for-each-model",level:3},{value:"<strong>1. Adjacency List Model</strong>",id:"1-adjacency-list-model-1",level:3},{value:"<strong>Query: Fetch a Subtree (Replies and Sub-replies)</strong>",id:"query-fetch-a-subtree-replies-and-sub-replies",level:4},{value:"<strong>Insert a Comment</strong>",id:"insert-a-comment",level:4},{value:"<strong>Advantages</strong>:",id:"advantages",level:4},{value:"<strong>Disadvantages</strong>:",id:"disadvantages",level:4},{value:"<strong>2. Nested Set Model</strong>",id:"2-nested-set-model-1",level:3},{value:"<strong>Query: Fetch a Subtree (Replies and Sub-replies)</strong>",id:"query-fetch-a-subtree-replies-and-sub-replies-1",level:4},{value:"<strong>Insert a Comment</strong>",id:"insert-a-comment-1",level:4},{value:"<strong>Advantages</strong>:",id:"advantages-1",level:4},{value:"<strong>Disadvantages</strong>:",id:"disadvantages-1",level:4},{value:"<strong>3. Path Enumeration Model</strong>",id:"3-path-enumeration-model-1",level:3},{value:"<strong>Query: Fetch a Subtree (Replies and Sub-replies)</strong>",id:"query-fetch-a-subtree-replies-and-sub-replies-2",level:4},{value:"<strong>Insert a Comment</strong>",id:"insert-a-comment-2",level:4},{value:"<strong>Advantages</strong>:",id:"advantages-2",level:4},{value:"<strong>Disadvantages</strong>:",id:"disadvantages-2",level:4},{value:"<strong>4. Materialized Path with DFS Index</strong>",id:"4-materialized-path-with-dfs-index-1",level:3},{value:"<strong>Query: Fetch a Subtree (Replies and Sub-replies)</strong>",id:"query-fetch-a-subtree-replies-and-sub-replies-3",level:4},{value:"<strong>Insert a Comment</strong>",id:"insert-a-comment-3",level:4},{value:"<strong>Advantages</strong>:",id:"advantages-3",level:4},{value:"<strong>Disadvantages</strong>:",id:"disadvantages-3",level:4},{value:"<strong>Real-World Recommendations</strong>",id:"real-world-recommendations",level:3},{value:"<strong>Choosing the Right Model</strong>",id:"choosing-the-right-model",level:4},{value:"<strong>Part 4: Performance Trade-Offs</strong>",id:"part-4-performance-trade-offs",level:3},{value:"<strong>Performance Comparison</strong>",id:"performance-comparison",level:3},{value:"1. <strong>Adjacency List Model</strong>",id:"1-adjacency-list-model-2",level:4},{value:"2. <strong>Nested Set Model</strong>",id:"2-nested-set-model-2",level:4},{value:"3. <strong>Path Enumeration Model</strong>",id:"3-path-enumeration-model-2",level:4},{value:"4. <strong>Materialized Path with DFS Index</strong>",id:"4-materialized-path-with-dfs-index-2",level:4},{value:"<strong>Real-World Examples</strong>",id:"real-world-examples",level:3},{value:"1. <strong>Reddit-Like Nested Comments</strong>",id:"1-reddit-like-nested-comments",level:4},{value:"2. <strong>Documentation System</strong>",id:"2-documentation-system",level:4},{value:"3. <strong>Basic Blog Comments</strong>",id:"3-basic-blog-comments",level:4},{value:"<strong>When to Combine Models</strong>",id:"when-to-combine-models",level:3},{value:"<strong>Part 5: Handling Dynamic Updates and Hybrid Approaches</strong>",id:"part-5-handling-dynamic-updates-and-hybrid-approaches",level:3},{value:"<strong>Dynamic Updates in Nested Comments</strong>",id:"dynamic-updates-in-nested-comments",level:3},{value:"<strong>1. Insertion</strong>",id:"1-insertion",level:4},{value:"<strong>2. Deletion</strong>",id:"2-deletion",level:4},{value:"<strong>3. Re-Parenting</strong>",id:"3-re-parenting",level:4},{value:"<strong>Hybrid Approaches</strong>",id:"hybrid-approaches",level:3},{value:"<strong>1. Combine Adjacency List with Materialized Path</strong>",id:"1-combine-adjacency-list-with-materialized-path",level:4},{value:"<strong>2. Combine Materialized Path with DFS Index</strong>",id:"2-combine-materialized-path-with-dfs-index",level:4},{value:"<strong>Performance Considerations</strong>",id:"performance-considerations",level:3},{value:"<strong>Real-World Use Case: Reddit-Style Nested Comments</strong>",id:"real-world-use-case-reddit-style-nested-comments",level:3},{value:"Problem:",id:"problem",level:4},{value:"Solution:",id:"solution",level:4},{value:"<strong>Part 6: Pagination Strategies for Nested Comments</strong>",id:"part-6-pagination-strategies-for-nested-comments",level:3},{value:"<strong>Pagination Requirements</strong>",id:"pagination-requirements",level:3},{value:"<strong>Strategies for Pagination</strong>",id:"strategies-for-pagination",level:3},{value:"<strong>1. Pagination for Adjacency List</strong>",id:"1-pagination-for-adjacency-list",level:4},{value:"<strong>Top-Level Pagination</strong>",id:"top-level-pagination",level:5},{value:"<strong>Nested Replies Pagination</strong>",id:"nested-replies-pagination",level:5},{value:"<strong>Challenges</strong>:",id:"challenges",level:5},{value:"<strong>2. Pagination for Materialized Path</strong>",id:"2-pagination-for-materialized-path",level:4},{value:"<strong>Top-Level Pagination</strong>",id:"top-level-pagination-1",level:5},{value:"<strong>Nested Replies Pagination</strong>",id:"nested-replies-pagination-1",level:5},{value:"<strong>Advantages</strong>:",id:"advantages-4",level:5},{value:"<strong>3. Pagination for Materialized Path with DFS Index</strong>",id:"3-pagination-for-materialized-path-with-dfs-index",level:4},{value:"<strong>Top-Level Pagination</strong>",id:"top-level-pagination-2",level:5},{value:"<strong>Nested Replies Pagination</strong>",id:"nested-replies-pagination-2",level:5},{value:"<strong>Advantages</strong>:",id:"advantages-5",level:5},{value:"<strong>Pagination Example: Reddit-Style Comments</strong>",id:"pagination-example-reddit-style-comments",level:3},{value:"Use Case",id:"use-case",level:4},{value:"Schema",id:"schema",level:4},{value:"Query Workflow",id:"query-workflow",level:4},{value:"<strong>Handling Infinite Scrolling</strong>",id:"handling-infinite-scrolling",level:3},{value:"Cursor-Based Pagination",id:"cursor-based-pagination",level:4},{value:"<strong>Comparison of Pagination Strategies</strong>",id:"comparison-of-pagination-strategies",level:3},{value:"<strong>Part 7: Scaling Nested Comments</strong>",id:"part-7-scaling-nested-comments",level:3},{value:"<strong>Key Challenges in Scaling Nested Comments</strong>",id:"key-challenges-in-scaling-nested-comments",level:3},{value:"<strong>Strategies for Scaling</strong>",id:"strategies-for-scaling",level:3},{value:"<strong>1. Database Sharding</strong>",id:"1-database-sharding",level:4},{value:"<strong>2. Caching</strong>",id:"2-caching",level:4},{value:"<strong>3. Asynchronous Processing</strong>",id:"3-asynchronous-processing",level:4},{value:"<strong>4. Denormalization</strong>",id:"4-denormalization",level:4},{value:"<strong>5. Read-Optimized Data Stores</strong>",id:"5-read-optimized-data-stores",level:4},{value:"<strong>6. Precomputed Views</strong>",id:"6-precomputed-views",level:4},{value:"<strong>Trade-Offs and Real-World Considerations</strong>",id:"trade-offs-and-real-world-considerations",level:3},{value:"<strong>Recommendations for Scaling</strong>",id:"recommendations-for-scaling",level:3},{value:"<strong>Part 8: Real-World Examples of Scaling Nested Comments</strong>",id:"part-8-real-world-examples-of-scaling-nested-comments",level:3},{value:"<strong>1. Reddit: Deeply Nested Threads</strong>",id:"1-reddit-deeply-nested-threads",level:3},{value:"<strong>Use Case</strong>:",id:"use-case-1",level:4},{value:"<strong>Challenges</strong>:",id:"challenges-1",level:4},{value:"<strong>Solution</strong>:",id:"solution-1",level:4},{value:"<strong>2. Facebook: Shallow Threads with High Traffic</strong>",id:"2-facebook-shallow-threads-with-high-traffic",level:3},{value:"<strong>Use Case</strong>:",id:"use-case-2",level:4},{value:"<strong>Challenges</strong>:",id:"challenges-2",level:4},{value:"<strong>Solution</strong>:",id:"solution-2",level:4},{value:"<strong>Optimization</strong>:",id:"optimization",level:4},{value:"<strong>3. Hacker News: Simplified Threaded Comments</strong>",id:"3-hacker-news-simplified-threaded-comments",level:3},{value:"<strong>Use Case</strong>:",id:"use-case-3",level:4},{value:"<strong>Challenges</strong>:",id:"challenges-3",level:4},{value:"<strong>Solution</strong>:",id:"solution-3",level:4},{value:"<strong>4. YouTube: Flat Comment Threads</strong>",id:"4-youtube-flat-comment-threads",level:3},{value:"<strong>Use Case</strong>:",id:"use-case-4",level:4},{value:"<strong>Challenges</strong>:",id:"challenges-4",level:4},{value:"<strong>Solution</strong>:",id:"solution-4",level:4},{value:"<strong>Optimization</strong>:",id:"optimization-1",level:4},{value:"<strong>Key Takeaways from Real-World Examples</strong>",id:"key-takeaways-from-real-world-examples",level:3}];function h(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"building-a-scalable-model-for-nested-comments",children:"Building a Scalable Model for Nested Comments"})}),"\n",(0,r.jsx)(n.p,{children:"Nested comments are a core feature in many applications, from social media platforms like Reddit and Facebook to content management systems. Designing a scalable database model to handle these comments efficiently is crucial. This post explores various approaches, their challenges, and trade-offs when implementing nested comments."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-1-core-challenges-of-nested-comments",children:(0,r.jsx)(n.strong,{children:"Part 1: Core Challenges of Nested Comments"})}),"\n",(0,r.jsx)(n.h4,{id:"what-makes-nested-comments-difficult",children:(0,r.jsx)(n.strong,{children:"What Makes Nested Comments Difficult?"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arbitrary Depth"}),": Users can keep replying to comments, creating trees with potentially unlimited depth."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Queries"}),": Applications often need to:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetch a comment and all its replies (subtree)."}),"\n",(0,r.jsx)(n.li,{children:"Retrieve only top-level comments and lazy-load replies."}),"\n",(0,r.jsx)(n.li,{children:"Order comments by time, votes, or relevance."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Updates"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New comments may be added at any level of the tree."}),"\n",(0,r.jsx)(n.li,{children:"Replies need to maintain hierarchy without requiring expensive updates."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pagination"}),": Large threads require efficient pagination of both top-level and nested replies."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"goals-of-a-good-design",children:(0,r.jsx)(n.strong,{children:"Goals of a Good Design"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query Efficiency"}),": Fast subtree retrieval and lazy loading."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Handle millions of comments and replies without performance degradation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexibility"}),": Support sorting, pagination, and dynamic updates."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-2-database-models-for-nested-comments",children:(0,r.jsx)(n.strong,{children:"Part 2: Database Models for Nested Comments"})}),"\n",(0,r.jsx)(n.p,{children:"Several database models are commonly used to represent nested comments. Each has strengths and weaknesses depending on the use case."}),"\n",(0,r.jsx)(n.h4,{id:"1-adjacency-list-model",children:(0,r.jsx)(n.strong,{children:"1. Adjacency List Model"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":\nEach comment stores a reference to its parent using a ",(0,r.jsx)(n.code,{children:"parent_id"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    parent_id INT NULL REFERENCES comments(id),\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Data"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ID"}),(0,r.jsx)(n.th,{children:"Parent ID"}),(0,r.jsx)(n.th,{children:"Content"}),(0,r.jsx)(n.th,{children:"Created At"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"NULL"}),(0,r.jsx)(n.td,{children:"Root comment"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:00:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Reply to Root"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:10:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Nested reply"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:15:00"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple and intuitive."}),"\n",(0,r.jsx)(n.li,{children:"Easy to insert and update comments."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetching an entire subtree requires recursive queries, which can be slow in SQL databases without recursive CTEs (Common Table Expressions)."}),"\n",(0,r.jsx)(n.li,{children:"Pagination of nested replies is non-trivial."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"2-nested-set-model",children:(0,r.jsx)(n.strong,{children:"2. Nested Set Model"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":\nThe tree is flattened into a single table, and each node is assigned a ",(0,r.jsx)(n.code,{children:"left"})," and ",(0,r.jsx)(n.code,{children:"right"})," value based on a depth-first traversal."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    left_id INT NOT NULL,\n    right_id INT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Data"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ID"}),(0,r.jsx)(n.th,{children:"Left ID"}),(0,r.jsx)(n.th,{children:"Right ID"}),(0,r.jsx)(n.th,{children:"Content"}),(0,r.jsx)(n.th,{children:"Created At"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{children:"Root comment"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:00:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Reply to Root"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:10:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"Another reply"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:20:00"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetching an entire subtree is a simple range query: ",(0,r.jsx)(n.code,{children:"SELECT * FROM comments WHERE left_id >= x AND right_id <= y"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"No recursive queries required."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Updates are expensive. Inserting or deleting a comment requires recalculating ",(0,r.jsx)(n.code,{children:"left_id"})," and ",(0,r.jsx)(n.code,{children:"right_id"})," for many nodes."]}),"\n",(0,r.jsx)(n.li,{children:"Not ideal for dynamic updates."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"3-path-enumeration-model",children:(0,r.jsx)(n.strong,{children:"3. Path Enumeration Model"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":\nEach comment stores its full path as a string (or array) representing its hierarchy."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    path TEXT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Data"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ID"}),(0,r.jsx)(n.th,{children:"Path"}),(0,r.jsx)(n.th,{children:"Content"}),(0,r.jsx)(n.th,{children:"Created At"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Root comment"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:00:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"1.2"}),(0,r.jsx)(n.td,{children:"Reply to Root"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:10:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"1.2.3"}),(0,r.jsx)(n.td,{children:"Nested reply"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:15:00"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetching a subtree is efficient with a ",(0,r.jsx)(n.code,{children:"LIKE"})," query: ",(0,r.jsx)(n.code,{children:"SELECT * FROM comments WHERE path LIKE '1.2.%'"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Insertion is straightforward\u2014just append to the parent's path."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Path strings grow longer with deeper nesting."}),"\n",(0,r.jsx)(n.li,{children:"Renaming or moving a subtree requires updating paths for all descendant nodes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"4-materialized-path-with-dfs-index",children:(0,r.jsx)(n.strong,{children:"4. Materialized Path with DFS Index"})}),"\n",(0,r.jsxs)(n.p,{children:["This model combines the ",(0,r.jsx)(n.strong,{children:"path enumeration model"})," with a ",(0,r.jsx)(n.strong,{children:"DFS-style index"})," (described in earlier posts)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":\nEach comment has:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"path"})," for subtree queries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," for range-based queries."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    path TEXT NOT NULL,\n    start_id INT NOT NULL,\n    end_id INT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Data"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ID"}),(0,r.jsx)(n.th,{children:"Path"}),(0,r.jsx)(n.th,{children:"Start ID"}),(0,r.jsx)(n.th,{children:"End ID"}),(0,r.jsx)(n.th,{children:"Content"}),(0,r.jsx)(n.th,{children:"Created At"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{children:"Root comment"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:00:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"1.2"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Reply to Root"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:10:00"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"1.2.3"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"Nested reply"}),(0,r.jsx)(n.td,{children:"2025-01-01 12:15:00"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Combines the benefits of both models:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Efficient subtree queries with ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Flexible subtree manipulation with ",(0,r.jsx)(n.code,{children:"path"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slightly more complex to implement."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-3-queries-for-each-model",children:(0,r.jsx)(n.strong,{children:"Part 3: Queries for Each Model"})}),"\n",(0,r.jsx)(n.p,{children:"Now, let\u2019s explore how common operations like fetching subtrees, inserting comments, and handling dynamic updates work in each model."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"1-adjacency-list-model-1",children:(0,r.jsx)(n.strong,{children:"1. Adjacency List Model"})}),"\n",(0,r.jsx)(n.h4,{id:"query-fetch-a-subtree-replies-and-sub-replies",children:(0,r.jsx)(n.strong,{children:"Query: Fetch a Subtree (Replies and Sub-replies)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Requires recursive queries using ",(0,r.jsx)(n.code,{children:"parent_id"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"In SQL databases supporting Common Table Expressions (CTEs), you can use a recursive query:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"WITH RECURSIVE CommentTree AS (\n    SELECT * FROM comments WHERE id = 1  -- Start with the root comment\n    UNION ALL\n    SELECT c.* \n    FROM comments c\n    INNER JOIN CommentTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CommentTree;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"insert-a-comment",children:(0,r.jsx)(n.strong,{children:"Insert a Comment"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Simply insert a row with the appropriate ",(0,r.jsx)(n.code,{children:"parent_id"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO comments (parent_id, content, created_at) \nVALUES (2, 'This is a new reply', NOW());\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"advantages",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple and intuitive schema."}),"\n",(0,r.jsx)(n.li,{children:"Easy to insert or update individual comments."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"disadvantages",children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetching a subtree is slow for deeply nested comments because recursive queries can be expensive."}),"\n",(0,r.jsx)(n.li,{children:"Poor performance for large trees or when pagination is required."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-nested-set-model-1",children:(0,r.jsx)(n.strong,{children:"2. Nested Set Model"})}),"\n",(0,r.jsx)(n.h4,{id:"query-fetch-a-subtree-replies-and-sub-replies-1",children:(0,r.jsx)(n.strong,{children:"Query: Fetch a Subtree (Replies and Sub-replies)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use a range query with ",(0,r.jsx)(n.code,{children:"left_id"})," and ",(0,r.jsx)(n.code,{children:"right_id"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE left_id >= 2 AND right_id <= 4\nORDER BY left_id;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"insert-a-comment-1",children:(0,r.jsx)(n.strong,{children:"Insert a Comment"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Inserting a comment requires recalculating the ",(0,r.jsx)(n.code,{children:"left_id"})," and ",(0,r.jsx)(n.code,{children:"right_id"})," for all affected nodes:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Shift the IDs of existing nodes to make space\nUPDATE comments \nSET left_id = CASE \n                  WHEN left_id >= 4 THEN left_id + 2 \n                  ELSE left_id \n              END,\n    right_id = CASE \n                  WHEN right_id >= 4 THEN right_id + 2 \n                  ELSE right_id \n              END;\n\n-- Insert the new comment\nINSERT INTO comments (left_id, right_id, content, created_at) \nVALUES (4, 5, 'This is a new reply', NOW());\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"advantages-1",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetching subtrees is very efficient (single range query)."}),"\n",(0,r.jsx)(n.li,{children:"Ordering of comments is inherent in the schema."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"disadvantages-1",children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Dynamic updates are expensive because they require recalculating IDs for many nodes."}),"\n",(0,r.jsx)(n.li,{children:"Poor scalability for systems with frequent insertions or deletions."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-path-enumeration-model-1",children:(0,r.jsx)(n.strong,{children:"3. Path Enumeration Model"})}),"\n",(0,r.jsx)(n.h4,{id:"query-fetch-a-subtree-replies-and-sub-replies-2",children:(0,r.jsx)(n.strong,{children:"Query: Fetch a Subtree (Replies and Sub-replies)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use a ",(0,r.jsx)(n.code,{children:"LIKE"})," query to find all descendants of a given comment:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path LIKE '1.2.%'\nORDER BY path;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"insert-a-comment-2",children:(0,r.jsx)(n.strong,{children:"Insert a Comment"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Generate a new ",(0,r.jsx)(n.code,{children:"path"})," based on the parent\u2019s path:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO comments (path, content, created_at) \nVALUES ('1.2.3', 'This is a new reply', NOW());\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"advantages-2",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Subtree queries are simple and efficient for shallow hierarchies."}),"\n",(0,r.jsx)(n.li,{children:"Dynamic updates are straightforward because no recalculation of existing nodes is needed."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"disadvantages-2",children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Path strings grow longer with deeper nesting."}),"\n",(0,r.jsx)(n.li,{children:"Moving a subtree (e.g., changing a parent) requires updating paths for all descendants."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-materialized-path-with-dfs-index-1",children:(0,r.jsx)(n.strong,{children:"4. Materialized Path with DFS Index"})}),"\n",(0,r.jsx)(n.h4,{id:"query-fetch-a-subtree-replies-and-sub-replies-3",children:(0,r.jsx)(n.strong,{children:"Query: Fetch a Subtree (Replies and Sub-replies)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," for range-based queries:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id >= 2 AND end_id <= 4\nORDER BY start_id;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"insert-a-comment-3",children:(0,r.jsx)(n.strong,{children:"Insert a Comment"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use the parent\u2019s ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," to calculate the new node\u2019s position:","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Find the parent node:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT start_id, end_id FROM comments WHERE id = 2;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Insert the new comment:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO comments (start_id, end_id, path, content, created_at) \nVALUES (3, 3, '1.2.3', 'This is a new reply', NOW());\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"advantages-3",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Combines the benefits of both path-based queries (",(0,r.jsx)(n.code,{children:"path"}),") and range-based queries (",(0,r.jsx)(n.code,{children:"start_id"}),", ",(0,r.jsx)(n.code,{children:"end_id"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Efficient for both static and dynamic hierarchies."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"disadvantages-3",children:[(0,r.jsx)(n.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slightly more complex schema and logic for maintaining indices."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"real-world-recommendations",children:(0,r.jsx)(n.strong,{children:"Real-World Recommendations"})}),"\n",(0,r.jsx)(n.h4,{id:"choosing-the-right-model",children:(0,r.jsx)(n.strong,{children:"Choosing the Right Model"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Adjacency List"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Best for small, shallow hierarchies with infrequent subtree queries."}),"\n",(0,r.jsx)(n.li,{children:"Works well if your database supports recursive CTEs."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nested Set"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ideal for static trees where insertions and deletions are rare."}),"\n",(0,r.jsx)(n.li,{children:"Perfect for forums or documentation systems with pre-defined hierarchies."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Path Enumeration"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Good for dynamic hierarchies with moderate depth."}),"\n",(0,r.jsx)(n.li,{children:"Simple to implement and efficient for most use cases."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path with DFS Index"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Best for systems requiring a balance of dynamic updates and efficient subtree queries."}),"\n",(0,r.jsx)(n.li,{children:"Suitable for nested comment systems in social media or content platforms like Reddit."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-4-performance-trade-offs",children:(0,r.jsx)(n.strong,{children:"Part 4: Performance Trade-Offs"})}),"\n",(0,r.jsxs)(n.p,{children:["Each model has specific trade-offs based on its strengths and weaknesses. Let\u2019s explore the ",(0,r.jsx)(n.strong,{children:"performance trade-offs"})," in detail and identify the best model for common scenarios."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"performance-comparison",children:(0,r.jsx)(n.strong,{children:"Performance Comparison"})}),"\n",(0,r.jsxs)(n.h4,{id:"1-adjacency-list-model-2",children:["1. ",(0,r.jsx)(n.strong,{children:"Adjacency List Model"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Operation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Reason"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fetch Subtree"}),(0,r.jsx)(n.td,{children:"Slow"}),(0,r.jsx)(n.td,{children:"Requires recursive queries; performance worsens with tree depth."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert a Comment"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Only involves inserting a single row without recalculations."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete a Comment"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Requires deleting the comment and optionally reassigning orphaned children."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Re-parent a Subtree"}),(0,r.jsx)(n.td,{children:"Difficult"}),(0,r.jsx)(n.td,{children:"Moving a subtree involves complex recursive updates."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pagination"}),(0,r.jsx)(n.td,{children:"Slow"}),(0,r.jsx)(n.td,{children:"Needs recursive queries to fetch paginated nested comments."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Use Case"}),": Suitable for shallow hierarchies or systems with limited subtree queries, especially if your database supports recursive CTEs."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h4,{id:"2-nested-set-model-2",children:["2. ",(0,r.jsx)(n.strong,{children:"Nested Set Model"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Operation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Reason"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fetch Subtree"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsxs)(n.td,{children:["Single range query based on ",(0,r.jsx)(n.code,{children:"left_id"})," and ",(0,r.jsx)(n.code,{children:"right_id"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert a Comment"}),(0,r.jsx)(n.td,{children:"Slow"}),(0,r.jsx)(n.td,{children:"Requires recalculating IDs for all nodes in the affected subtree."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete a Comment"}),(0,r.jsx)(n.td,{children:"Slow"}),(0,r.jsx)(n.td,{children:"Similar to insertion; recalculates IDs for all affected nodes."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Re-parent a Subtree"}),(0,r.jsx)(n.td,{children:"Very Slow"}),(0,r.jsxs)(n.td,{children:["Entire tree needs re-indexing to adjust ",(0,r.jsx)(n.code,{children:"left_id"})," and ",(0,r.jsx)(n.code,{children:"right_id"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pagination"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Subtree and pagination are inherent with range queries."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Use Case"}),": Ideal for static hierarchies, such as documentation trees, where updates are rare."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h4,{id:"3-path-enumeration-model-2",children:["3. ",(0,r.jsx)(n.strong,{children:"Path Enumeration Model"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Operation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Reason"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fetch Subtree"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsxs)(n.td,{children:["Simple prefix-based queries using ",(0,r.jsx)(n.code,{children:"LIKE"})," or array operations."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert a Comment"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Requires appending the parent path."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete a Comment"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Single row deletion; no recalculations needed for siblings."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Re-parent a Subtree"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Requires updating paths for all descendants, but no complex recalculations."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pagination"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Sorting by path or timestamp works, but requires careful handling."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Use Case"}),": Dynamic hierarchies with moderate depth, such as nested comment systems with frequent updates."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h4,{id:"4-materialized-path-with-dfs-index-2",children:["4. ",(0,r.jsx)(n.strong,{children:"Materialized Path with DFS Index"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Operation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Reason"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fetch Subtree"}),(0,r.jsx)(n.td,{children:"Very Fast"}),(0,r.jsxs)(n.td,{children:["Combines range queries (",(0,r.jsx)(n.code,{children:"start_id"}),", ",(0,r.jsx)(n.code,{children:"end_id"}),") and prefix-based queries (",(0,r.jsx)(n.code,{children:"path"}),")."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert a Comment"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsxs)(n.td,{children:["Requires updating paths and calculating new ",(0,r.jsx)(n.code,{children:"start_id"}),", ",(0,r.jsx)(n.code,{children:"end_id"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete a Comment"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Deletes the comment and adjusts indices for descendants."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Re-parent a Subtree"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsxs)(n.td,{children:["Updates ",(0,r.jsx)(n.code,{children:"path"})," for descendants but doesn't require recalculating indices."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pagination"}),(0,r.jsx)(n.td,{children:"Very Fast"}),(0,r.jsx)(n.td,{children:"Easily integrates range and timestamp-based pagination."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Use Case"}),": Complex dynamic systems with frequent subtree queries, such as social media platforms like Reddit."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"real-world-examples",children:(0,r.jsx)(n.strong,{children:"Real-World Examples"})}),"\n",(0,r.jsxs)(n.h4,{id:"1-reddit-like-nested-comments",children:["1. ",(0,r.jsx)(n.strong,{children:"Reddit-Like Nested Comments"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model"}),": Materialized Path with DFS Index"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why"}),": Efficient subtree queries (",(0,r.jsx)(n.code,{children:"start_id"}),", ",(0,r.jsx)(n.code,{children:"end_id"}),") for fetching threads, combined with dynamic updates (",(0,r.jsx)(n.code,{children:"path"}),") for replies."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query"}),":\nFetch a comment and all replies:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id >= 100 AND end_id <= 200\nORDER BY start_id;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h4,{id:"2-documentation-system",children:["2. ",(0,r.jsx)(n.strong,{children:"Documentation System"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model"}),": Nested Set"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why"}),": Static hierarchy where updates are rare, and subtree retrieval is critical."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query"}),":\nFetch all child nodes under a section:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE left_id >= 10 AND right_id <= 20\nORDER BY left_id;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h4,{id:"3-basic-blog-comments",children:["3. ",(0,r.jsx)(n.strong,{children:"Basic Blog Comments"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model"}),": Adjacency List"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why"}),": Simple, shallow hierarchies without complex queries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query"}),":\nFetch all direct replies to a comment:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id = 5\nORDER BY created_at;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"when-to-combine-models",children:(0,r.jsx)(n.strong,{children:"When to Combine Models"})}),"\n",(0,r.jsx)(n.p,{children:"For complex systems, it\u2019s common to combine multiple models:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"Adjacency List"})," for quick inserts and updates."]}),"\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.strong,{children:"DFS Index"})," for efficient subtree queries."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"Path Enumeration"})," for re-parenting flexibility."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-5-handling-dynamic-updates-and-hybrid-approaches",children:(0,r.jsx)(n.strong,{children:"Part 5: Handling Dynamic Updates and Hybrid Approaches"})}),"\n",(0,r.jsx)(n.p,{children:"Dynamic systems like nested comments often require efficient handling of updates, including new comment insertion, deletions, and re-parenting subtrees. Hybrid approaches combine the strengths of different models to meet these needs."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-updates-in-nested-comments",children:(0,r.jsx)(n.strong,{children:"Dynamic Updates in Nested Comments"})}),"\n",(0,r.jsx)(n.h4,{id:"1-insertion",children:(0,r.jsx)(n.strong,{children:"1. Insertion"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Challenge"}),": Adding a comment dynamically must maintain the hierarchical structure."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Approaches"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adjacency List"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add a new comment by specifying its ",(0,r.jsx)(n.code,{children:"parent_id"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Query time remains unaffected since no recalculations are needed."}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO comments (parent_id, content, created_at) \nVALUES (5, 'This is a reply to comment 5', NOW());\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Append to the parent\u2019s path for the new comment."}),"\n",(0,r.jsxs)(n.li,{children:["Use decimal or fractional IDs if needed for ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO comments (path, start_id, end_id, content, created_at) \nVALUES ('1.2.3', 8, 8, 'Nested reply to 1.2', NOW());\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"2-deletion",children:(0,r.jsx)(n.strong,{children:"2. Deletion"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Challenge"}),": Removing a comment may leave orphaned replies or require recalculating indices."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Approaches"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adjacency List"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Delete a comment, then decide how to handle orphaned children:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Either cascade delete or reassign them to a higher parent."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"DELETE FROM comments WHERE id = 5;\n-- Optional: Reassign orphaned children\nUPDATE comments SET parent_id = 1 WHERE parent_id = 5;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Remove the comment and reassign paths for its descendants."}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"DELETE FROM comments WHERE start_id = 8 AND end_id = 8;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"3-re-parenting",children:(0,r.jsx)(n.strong,{children:"3. Re-Parenting"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Challenge"}),": Moving a subtree to a new parent requires updating hierarchical data efficiently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Approaches"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adjacency List"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Update the ",(0,r.jsx)(n.code,{children:"parent_id"})," of the subtree's root node."]}),"\n",(0,r.jsx)(n.li,{children:"No need for recalculations."}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"UPDATE comments SET parent_id = 10 WHERE id = 5;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Update the ",(0,r.jsx)(n.code,{children:"path"})," for the entire subtree."]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"UPDATE comments SET path = REPLACE(path, '1.2', '1.3') WHERE path LIKE '1.2.%';\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"hybrid-approaches",children:(0,r.jsx)(n.strong,{children:"Hybrid Approaches"})}),"\n",(0,r.jsx)(n.h4,{id:"1-combine-adjacency-list-with-materialized-path",children:(0,r.jsx)(n.strong,{children:"1. Combine Adjacency List with Materialized Path"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Idea"}),": Use ",(0,r.jsx)(n.code,{children:"parent_id"})," for direct parent-child relationships and ",(0,r.jsx)(n.code,{children:"path"})," for efficient subtree queries."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    parent_id INT NULL,\n    path TEXT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Simple insertion with ",(0,r.jsx)(n.code,{children:"parent_id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Efficient subtree queries with ",(0,r.jsx)(n.code,{children:"path"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Queries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch all replies to a comment:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM comments WHERE path LIKE '1.2.%' ORDER BY path;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"2-combine-materialized-path-with-dfs-index",children:(0,r.jsx)(n.strong,{children:"2. Combine Materialized Path with DFS Index"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Idea"}),": Use ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," for range queries and ",(0,r.jsx)(n.code,{children:"path"})," for flexibility in dynamic updates."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    path TEXT NOT NULL,\n    start_id INT NOT NULL,\n    end_id INT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Efficient subtree queries with ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Flexibility for re-parenting using ",(0,r.jsx)(n.code,{children:"path"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Queries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch all replies to a comment:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id >= 2 AND end_id <= 4\nORDER BY start_id;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Re-parent a subtree:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"UPDATE comments SET path = REPLACE(path, '1.2', '1.3') WHERE path LIKE '1.2.%';\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"performance-considerations",children:(0,r.jsx)(n.strong,{children:"Performance Considerations"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Operation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Adjacency List"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Materialized Path"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Hybrid"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Insertion"})}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Fast"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Deletion"})}),(0,r.jsx)(n.td,{children:"Moderate (cascade logic)"}),(0,r.jsx)(n.td,{children:"Moderate (path updates)"}),(0,r.jsx)(n.td,{children:"Moderate"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Re-Parenting"})}),(0,r.jsx)(n.td,{children:"Difficult"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Easy"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Fetch Subtree"})}),(0,r.jsx)(n.td,{children:"Slow (recursive queries)"}),(0,r.jsx)(n.td,{children:"Fast (range or prefix query)"}),(0,r.jsx)(n.td,{children:"Fast"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Pagination"})}),(0,r.jsx)(n.td,{children:"Difficult"}),(0,r.jsxs)(n.td,{children:["Moderate (with ",(0,r.jsx)(n.code,{children:"path"}),")"]}),(0,r.jsx)(n.td,{children:"Fast"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"real-world-use-case-reddit-style-nested-comments",children:(0,r.jsx)(n.strong,{children:"Real-World Use Case: Reddit-Style Nested Comments"})}),"\n",(0,r.jsx)(n.h4,{id:"problem",children:"Problem:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Efficiently fetch top-level comments and lazily load nested replies."}),"\n",(0,r.jsx)(n.li,{children:"Support dynamic updates, like adding replies or deleting subtrees."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"solution",children:"Solution:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hybrid Model"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"parent_id"})," for quick insertion."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"path"})," and ",(0,r.jsx)(n.code,{children:"start_id"}),"/",(0,r.jsx)(n.code,{children:"end_id"})," for efficient subtree and pagination queries."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add a Comment"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Insert into the table with the parent\u2019s ",(0,r.jsx)(n.code,{children:"path"})," and dynamically assign ",(0,r.jsx)(n.code,{children:"start_id"}),"/",(0,r.jsx)(n.code,{children:"end_id"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fetch Comments"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch top-level comments using:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM comments WHERE parent_id IS NULL ORDER BY created_at LIMIT 10;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Fetch replies using:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM comments WHERE path LIKE '1.%' ORDER BY path;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-6-pagination-strategies-for-nested-comments",children:(0,r.jsx)(n.strong,{children:"Part 6: Pagination Strategies for Nested Comments"})}),"\n",(0,r.jsx)(n.p,{children:"Pagination is critical for systems with large datasets, such as nested comments, where loading all comments at once is impractical. A well-designed pagination strategy ensures efficient and user-friendly navigation through top-level comments and their nested replies."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"pagination-requirements",children:(0,r.jsx)(n.strong,{children:"Pagination Requirements"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Top-Level Pagination"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetch top-level comments with metadata (e.g., number of replies, votes) and limit the number of results."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nested Replies Pagination"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Load replies for a specific comment lazily, ensuring only a small subset of replies is loaded at a time."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Infinite Scrolling"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allow users to scroll through comments seamlessly by fetching additional comments dynamically."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Efficient Queries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Queries should scale with the dataset size and support sorting by relevance, time, or votes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"strategies-for-pagination",children:(0,r.jsx)(n.strong,{children:"Strategies for Pagination"})}),"\n",(0,r.jsx)(n.h4,{id:"1-pagination-for-adjacency-list",children:(0,r.jsx)(n.strong,{children:"1. Pagination for Adjacency List"})}),"\n",(0,r.jsxs)(n.p,{children:["In the adjacency list model, pagination can be achieved using ",(0,r.jsx)(n.code,{children:"LIMIT"})," and ",(0,r.jsx)(n.code,{children:"OFFSET"})," for top-level comments and a recursive approach for nested replies."]}),"\n",(0,r.jsx)(n.h5,{id:"top-level-pagination",children:(0,r.jsx)(n.strong,{children:"Top-Level Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch a limited number of top-level comments ordered by timestamp or votes:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id IS NULL\nORDER BY created_at DESC\nLIMIT 10 OFFSET 20;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"nested-replies-pagination",children:(0,r.jsx)(n.strong,{children:"Nested Replies Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch replies for a given parent comment with a limit:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id = 5\nORDER BY created_at ASC\nLIMIT 5 OFFSET 10;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"challenges",children:[(0,r.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deep Nesting"}),": Recursive queries are required to fetch nested replies, which can be inefficient."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offset Performance"}),": For large datasets, using ",(0,r.jsx)(n.code,{children:"OFFSET"})," can become slow as the database scans through rows to find the starting point."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"2-pagination-for-materialized-path",children:(0,r.jsx)(n.strong,{children:"2. Pagination for Materialized Path"})}),"\n",(0,r.jsx)(n.p,{children:"Materialized path simplifies subtree queries by using prefix-based searches for nested replies."}),"\n",(0,r.jsx)(n.h5,{id:"top-level-pagination-1",children:(0,r.jsx)(n.strong,{children:"Top-Level Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch top-level comments with no parent:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path = '1'\nORDER BY created_at DESC\nLIMIT 10;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"nested-replies-pagination-1",children:(0,r.jsx)(n.strong,{children:"Nested Replies Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch a limited number of replies for a specific path:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path LIKE '1.2.%'\nORDER BY path\nLIMIT 5 OFFSET 10;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"advantages-4",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Efficient for hierarchical queries."}),"\n",(0,r.jsx)(n.li,{children:"Easy to implement for lazy loading."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"3-pagination-for-materialized-path-with-dfs-index",children:(0,r.jsx)(n.strong,{children:"3. Pagination for Materialized Path with DFS Index"})}),"\n",(0,r.jsxs)(n.p,{children:["The hybrid approach combining ",(0,r.jsx)(n.code,{children:"path"})," and DFS indices (",(0,r.jsx)(n.code,{children:"start_id"}),", ",(0,r.jsx)(n.code,{children:"end_id"}),") allows range-based pagination for both top-level comments and nested replies."]}),"\n",(0,r.jsx)(n.h5,{id:"top-level-pagination-2",children:(0,r.jsx)(n.strong,{children:"Top-Level Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use range queries with sorting to fetch top-level comments:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id IS NULL\nORDER BY start_id\nLIMIT 10;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"nested-replies-pagination-2",children:(0,r.jsx)(n.strong,{children:"Nested Replies Pagination"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch replies within the ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," range for a parent:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id >= 10 AND end_id <= 20\nORDER BY start_id\nLIMIT 5 OFFSET 0;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"advantages-5",children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Combines efficient subtree retrieval with range-based pagination."}),"\n",(0,r.jsx)(n.li,{children:"Allows fetching comments lazily without excessive database scans."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"pagination-example-reddit-style-comments",children:(0,r.jsx)(n.strong,{children:"Pagination Example: Reddit-Style Comments"})}),"\n",(0,r.jsx)(n.h4,{id:"use-case",children:"Use Case"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A user views a thread with thousands of comments."}),"\n",(0,r.jsx)(n.li,{children:"The system fetches the first 10 top-level comments, sorted by time or votes."}),"\n",(0,r.jsx)(n.li,{children:"For each comment, replies are fetched lazily when the user expands the thread."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"schema",children:"Schema"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    parent_id INT NULL,\n    path TEXT NOT NULL,\n    start_id INT NOT NULL,\n    end_id INT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"query-workflow",children:"Query Workflow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fetch Top-Level Comments"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id IS NULL\nORDER BY start_id\nLIMIT 10;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Lazy Load Replies"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path LIKE '1.%'\nORDER BY path\nLIMIT 5 OFFSET 0;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Efficient Range Queries"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For deeply nested comments, use range-based queries:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id >= 15 AND end_id <= 30\nORDER BY start_id\nLIMIT 5;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"handling-infinite-scrolling",children:(0,r.jsx)(n.strong,{children:"Handling Infinite Scrolling"})}),"\n",(0,r.jsxs)(n.p,{children:["For infinite scrolling, instead of using ",(0,r.jsx)(n.code,{children:"OFFSET"}),", use a ",(0,r.jsx)(n.strong,{children:"cursor-based pagination"})," strategy for better performance."]}),"\n",(0,r.jsx)(n.h4,{id:"cursor-based-pagination",children:"Cursor-Based Pagination"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"start_id"})," of the last loaded comment as a cursor."]}),"\n",(0,r.jsxs)(n.li,{children:["Fetch the next batch of comments starting from the cursor:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE start_id > 20\nORDER BY start_id\nLIMIT 10;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"comparison-of-pagination-strategies",children:(0,r.jsx)(n.strong,{children:"Comparison of Pagination Strategies"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Model"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Top-Level Pagination"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Nested Replies Pagination"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Performance"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Adjacency List"})}),(0,r.jsxs)(n.td,{children:["Simple with ",(0,r.jsx)(n.code,{children:"LIMIT"})," and ",(0,r.jsx)(n.code,{children:"OFFSET"})]}),(0,r.jsx)(n.td,{children:"Recursive queries for nesting"}),(0,r.jsx)(n.td,{children:"Inefficient for deep trees"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Materialized Path"})}),(0,r.jsx)(n.td,{children:"Efficient with prefix queries"}),(0,r.jsxs)(n.td,{children:["Simple with ",(0,r.jsx)(n.code,{children:"LIKE"})," and range queries"]}),(0,r.jsx)(n.td,{children:"Scales well for moderate nesting"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Materialized Path + DFS Index"})}),(0,r.jsx)(n.td,{children:"Efficient with range queries"}),(0,r.jsxs)(n.td,{children:["Fast with ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})]}),(0,r.jsx)(n.td,{children:"Best for large-scale systems with frequent updates"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-7-scaling-nested-comments",children:(0,r.jsx)(n.strong,{children:"Part 7: Scaling Nested Comments"})}),"\n",(0,r.jsx)(n.p,{children:"Scaling nested comments involves ensuring that the system can handle increasing volumes of data, users, and requests without degrading performance. This requires architectural considerations, database optimizations, and caching strategies."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"key-challenges-in-scaling-nested-comments",children:(0,r.jsx)(n.strong,{children:"Key Challenges in Scaling Nested Comments"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High Volume of Data"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Large-scale systems like Reddit or Facebook have millions of comments, potentially in a single thread."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Frequent Reads"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Comment threads are read-heavy, with users frequently viewing threads while only occasionally adding new comments."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Updates"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New comments, edits, and deletions must be handled dynamically without significantly impacting performance."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nested Queries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Retrieving subtrees or paginated replies for deeply nested threads requires efficient query execution."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"strategies-for-scaling",children:(0,r.jsx)(n.strong,{children:"Strategies for Scaling"})}),"\n",(0,r.jsx)(n.h4,{id:"1-database-sharding",children:(0,r.jsx)(n.strong,{children:"1. Database Sharding"})}),"\n",(0,r.jsx)(n.p,{children:"Split the comments table across multiple shards to distribute the load and increase capacity."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shard Key"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use a combination of ",(0,r.jsx)(n.code,{children:"thread_id"})," and ",(0,r.jsx)(n.code,{children:"start_id"})," (or ",(0,r.jsx)(n.code,{children:"path"}),") to partition data."]}),"\n",(0,r.jsx)(n.li,{children:"Ensures that all comments in a thread are stored on the same shard, minimizing cross-shard queries."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Schema"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments_shard_1 (\n    id SERIAL PRIMARY KEY,\n    thread_id INT NOT NULL,\n    start_id INT NOT NULL,\n    path TEXT NOT NULL,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Route queries to the appropriate shard using the ",(0,r.jsx)(n.code,{children:"thread_id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments_shard_1 \nWHERE thread_id = 101 AND start_id >= 10 AND end_id <= 20;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"2-caching",children:(0,r.jsx)(n.strong,{children:"2. Caching"})}),"\n",(0,r.jsx)(n.p,{children:"Use an in-memory cache (e.g., Redis, Memcached) to reduce database load for frequently accessed threads."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cache Structure"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store top-level comments and their immediate replies in the cache."}),"\n",(0,r.jsxs)(n.li,{children:["Use a hierarchical key structure to cache nested replies:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:"thread:<thread_id>:comment:<comment_id>"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check the cache for the requested comments."}),"\n",(0,r.jsx)(n.li,{children:"If the data is missing, query the database and populate the cache."}),"\n",(0,r.jsx)(n.li,{children:"Return the cached data to subsequent requests."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example with Redis"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Store comments in Redis\nSET thread:101:comment:5 \"[{id: 6, content: 'Reply 1'}, {id: 7, content: 'Reply 2'}]\"\n\n# Retrieve comments from Redis\nGET thread:101:comment:5\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"3-asynchronous-processing",children:(0,r.jsx)(n.strong,{children:"3. Asynchronous Processing"})}),"\n",(0,r.jsx)(n.p,{children:"Offload complex operations, such as subtree updates or large comment deletions, to asynchronous job queues."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example Workflow"}),":","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A new comment is added to a large thread."}),"\n",(0,r.jsxs)(n.li,{children:["Instead of recalculating ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," immediately, enqueue the operation in a job queue (e.g., RabbitMQ, Kafka)."]}),"\n",(0,r.jsx)(n.li,{children:"A worker process updates the indices asynchronously, minimizing the impact on real-time requests."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"4-denormalization",children:(0,r.jsx)(n.strong,{children:"4. Denormalization"})}),"\n",(0,r.jsx)(n.p,{children:"Store precomputed data (e.g., subtree sizes, reply counts) to avoid expensive computations at query time."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE comments (\n    id SERIAL PRIMARY KEY,\n    parent_id INT NULL,\n    path TEXT NOT NULL,\n    start_id INT NOT NULL,\n    end_id INT NOT NULL,\n    reply_count INT DEFAULT 0,\n    content TEXT,\n    created_at TIMESTAMP\n);\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Increment the ",(0,r.jsx)(n.code,{children:"reply_count"})," of the parent comment when a new reply is added."]}),"\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"reply_count"}),' for UI elements like "Show X replies" without querying the database.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"5-read-optimized-data-stores",children:(0,r.jsx)(n.strong,{children:"5. Read-Optimized Data Stores"})}),"\n",(0,r.jsx)(n.p,{children:"Consider using read-optimized databases like Elasticsearch for searching and retrieving comments at scale."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast full-text search for comment content."}),"\n",(0,r.jsx)(n.li,{children:"Efficient filtering and sorting based on time, votes, or relevance."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sync the comments database with Elasticsearch using a Change Data Capture (CDC) system (e.g., Kafka Connect)."}),"\n",(0,r.jsx)(n.li,{children:"Query Elasticsearch for read-heavy operations."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Query"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "query": {\n        "bool": {\n            "must": [\n                { "term": { "thread_id": 101 } },\n                { "range": { "created_at": { "gte": "2025-01-01" } } }\n            ]\n        }\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"6-precomputed-views",children:(0,r.jsx)(n.strong,{children:"6. Precomputed Views"})}),"\n",(0,r.jsx)(n.p,{children:"Materialize frequently accessed data into precomputed views (e.g., a flattened thread structure)."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Store a flattened view of comments for each thread in a separate table:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE thread_flattened (\n    thread_id INT,\n    flattened_comments JSONB\n);\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch the entire thread structure in a single query:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT flattened_comments \nFROM thread_flattened \nWHERE thread_id = 101;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"trade-offs-and-real-world-considerations",children:(0,r.jsx)(n.strong,{children:"Trade-Offs and Real-World Considerations"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Scaling Strategy"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Advantages"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Challenges"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Sharding"})}),(0,r.jsx)(n.td,{children:"Handles high data volume; reduces hotspots"}),(0,r.jsx)(n.td,{children:"Complex cross-shard queries; requires routing."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Caching"})}),(0,r.jsx)(n.td,{children:"Low latency for frequent reads"}),(0,r.jsx)(n.td,{children:"Cache invalidation for dynamic updates."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Asynchronous Processing"})}),(0,r.jsx)(n.td,{children:"Reduces impact of expensive operations"}),(0,r.jsx)(n.td,{children:"Requires robust job queue and worker processes."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Denormalization"})}),(0,r.jsx)(n.td,{children:"Improves read performance"}),(0,r.jsx)(n.td,{children:"Increases storage and complexity of writes."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Read-Optimized Stores"})}),(0,r.jsx)(n.td,{children:"Fast search and filtering"}),(0,r.jsx)(n.td,{children:"Additional infrastructure; eventual consistency."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Precomputed Views"})}),(0,r.jsx)(n.td,{children:"Fast reads for entire threads"}),(0,r.jsx)(n.td,{children:"Expensive to maintain for frequently updated data."})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"recommendations-for-scaling",children:(0,r.jsx)(n.strong,{children:"Recommendations for Scaling"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Start Simple"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Begin with a relational database and basic caching for small-scale systems."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Introduce Optimizations Gradually"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"As the system grows, add sharding, denormalization, and precomputed views as needed."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimize for Read-Heavy Workloads"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use a combination of caching and read-optimized data stores like Elasticsearch."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Leverage Asynchronous Processing"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Offload expensive operations to job queues to keep the user experience fast."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"part-8-real-world-examples-of-scaling-nested-comments",children:(0,r.jsx)(n.strong,{children:"Part 8: Real-World Examples of Scaling Nested Comments"})}),"\n",(0,r.jsxs)(n.p,{children:["To better understand how scaling nested comments works in practice, let's explore real-world examples from popular platforms like ",(0,r.jsx)(n.strong,{children:"Reddit"}),", ",(0,r.jsx)(n.strong,{children:"Facebook"}),", and ",(0,r.jsx)(n.strong,{children:"Hacker News"}),". Each platform has unique requirements, which influence the architecture and design choices for handling nested comments."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"1-reddit-deeply-nested-threads",children:(0,r.jsx)(n.strong,{children:"1. Reddit: Deeply Nested Threads"})}),"\n",(0,r.jsxs)(n.h4,{id:"use-case-1",children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reddit supports highly nested comment threads with dynamic voting, collapsing, and sorting based on relevance, time, or popularity."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"challenges-1",children:[(0,r.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deep Nesting"}),": Comments can have arbitrary depths, requiring efficient subtree retrieval."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Sorting"}),': Comments are sorted by upvotes, time, or a combination (e.g., "Hot" ranking).']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large Threads"}),": Popular threads can have millions of comments, requiring efficient pagination and lazy loading."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"solution-1",children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hybrid Approach"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use paths to represent hierarchy, enabling efficient subtree queries and lazy loading."}),"\n",(0,r.jsxs)(n.li,{children:["Example Path: ",(0,r.jsx)(n.code,{children:'"1/2/3"'})," (Comment 3 is a reply to Comment 2, which is a reply to Comment 1)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DFS Index"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"start_id"})," and ",(0,r.jsx)(n.code,{children:"end_id"})," for fast range-based queries."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Database"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Primary Storage"}),": Relational database (e.g., PostgreSQL)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search and Ranking"}),": Elasticsearch for sorting and filtering based on votes, time, or relevance."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch top-level comments:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path = '1'\nORDER BY votes DESC, created_at ASC \nLIMIT 10;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Fetch nested replies:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE path LIKE '1/2.%'\nORDER BY path \nLIMIT 5;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Use Elasticsearch for relevance ranking:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "query": {\n        "bool": {\n            "must": [\n                { "term": { "thread_id": 101 } },\n                { "range": { "created_at": { "gte": "2025-01-01" } } }\n            ],\n            "should": [\n                { "term": { "votes": 10 } },\n                { "term": { "relevance_score": 5 } }\n            ]\n        }\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-facebook-shallow-threads-with-high-traffic",children:(0,r.jsx)(n.strong,{children:"2. Facebook: Shallow Threads with High Traffic"})}),"\n",(0,r.jsxs)(n.h4,{id:"use-case-2",children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Facebook comments are typically shallow (1-2 levels deep) and focus on high throughput for reads and writes."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"challenges-2",children:[(0,r.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Traffic"}),": Billions of users interacting with posts and comments simultaneously."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shallow Hierarchies"}),": Most comments and replies are limited to 1-2 levels deep."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-Time Updates"}),": New comments, likes, and replies must propagate to users instantly."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"solution-2",children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Adjacency List"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"parent_id"})," for parent-child relationships, as the shallow structure minimizes recursive queries."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Denormalized Views"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Precompute comment counts and store the most recent replies directly in the post metadata."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Database"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Primary Storage"}),": Distributed NoSQL database (e.g., RocksDB or Cassandra) for high throughput."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache"}),": Redis or Memcached for frequently accessed threads."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch top-level comments:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE post_id = 101 AND parent_id IS NULL \nORDER BY created_at DESC \nLIMIT 10;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Fetch replies:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id = 5 \nORDER BY created_at ASC \nLIMIT 5;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"optimization",children:[(0,r.jsx)(n.strong,{children:"Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use precomputed fields for quick access:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"reply_count"}),": Total replies for a comment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"last_reply"}),": Timestamp of the most recent reply."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-hacker-news-simplified-threaded-comments",children:(0,r.jsx)(n.strong,{children:"3. Hacker News: Simplified Threaded Comments"})}),"\n",(0,r.jsxs)(n.h4,{id:"use-case-3",children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Hacker News uses a relatively simple nested comment system, with fixed sorting by time and votes."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"challenges-3",children:[(0,r.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Fetching"}),": Retrieving nested comments for a thread with minimal latency."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixed Sorting"}),": Comments are ordered by time or score without dynamic ranking."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"solution-3",children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Materialized Path with Recursive Queries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use a simple path-based hierarchy for nesting."}),"\n",(0,r.jsx)(n.li,{children:"Combine with recursive queries for flexibility."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Database"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Relational database (e.g., SQLite or MySQL), as the comment volume is manageable."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch comments recursively for a thread:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"WITH RECURSIVE CommentTree AS (\n    SELECT * FROM comments WHERE id = 1\n    UNION ALL\n    SELECT c.* FROM comments c \n    INNER JOIN CommentTree ct ON c.parent_id = ct.id\n)\nSELECT * FROM CommentTree ORDER BY created_at ASC;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prefetch the top-level comments for threads during page load."}),"\n",(0,r.jsx)(n.li,{children:"Fetch nested replies lazily when users expand a comment."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-youtube-flat-comment-threads",children:(0,r.jsx)(n.strong,{children:"4. YouTube: Flat Comment Threads"})}),"\n",(0,r.jsxs)(n.h4,{id:"use-case-4",children:[(0,r.jsx)(n.strong,{children:"Use Case"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"YouTube comments are primarily flat, with a single level of replies."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"challenges-4",children:[(0,r.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flat Structure"}),": Replies are not deeply nested but must still be grouped under their parent."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Volume"}),": Popular videos can have millions of comments."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"solution-4",children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flat Table with Reply Groups"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store parent-child relationships in a flat table."}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"parent_id"})," to group replies."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Database"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distributed NoSQL database for scalability."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch top-level comments:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE video_id = 101 AND parent_id IS NULL \nORDER BY votes DESC \nLIMIT 20;\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Fetch replies for a comment:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * \nFROM comments \nWHERE parent_id = 5 \nORDER BY created_at ASC \nLIMIT 10;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"optimization-1",children:[(0,r.jsx)(n.strong,{children:"Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache the most upvoted comments for popular videos."}),"\n",(0,r.jsx)(n.li,{children:"Use precomputed reply counts for UI."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways-from-real-world-examples",children:(0,r.jsx)(n.strong,{children:"Key Takeaways from Real-World Examples"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"System-Specific Models"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use simpler models (e.g., adjacency lists) for shallow hierarchies."}),"\n",(0,r.jsx)(n.li,{children:"Use hybrid or materialized path models for deep, dynamic hierarchies."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Caching"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache frequently accessed threads and comments to reduce database load."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Read-Heavy Systems"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prioritize read-optimized databases like Elasticsearch for search and ranking."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Updates"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Handle expensive operations like re-parenting and subtree updates asynchronously to maintain responsiveness."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function o(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>d});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);