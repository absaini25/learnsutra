"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"test","metadata":{"permalink":"/blog/test","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-11-29-test.md","source":"@site/blog/2024-11-29-test.md","title":"Dynamic Programing","description":"Real-World Applications of Dynamic Programming","date":"2024-11-29T00:00:00.000Z","tags":[{"inline":false,"label":"Hola","permalink":"/blog/tags/hola","description":"Hola tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":14.695,"hasTruncateMarker":false,"authors":[{"name":"Abhisar Saini","title":"Principal Software Engineer @ Expedia","url":"https://github.com/absaini25","page":{"permalink":"/blog/authors/absaini-25"},"socials":{"x":"https://x.com/yangshunz","github":"https://github.com/yangshun"},"imageURL":"https://github.com/absaini25.png","key":"absaini25"}],"frontMatter":{"slug":"test","title":"Dynamic Programing","authors":["absaini25"],"tags":["hola","docusaurus"]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"### **Real-World Applications of Dynamic Programming**\\n\\nDynamic Programming (DP) has practical applications in a variety of domains, including scheduling, game theory, and even real-world decision-making processes like dynamic pricing and resource allocation. In this section, we\u2019ll explore **Job Scheduling**, **Game Theory** (specifically Minimax with DP), and other examples, complete with Java code implementations.\\n\\n---\\n\\n### **1. Job Scheduling with Deadlines and Profits**\\n\\n#### **Problem Statement**\\nYou are given $ n $ jobs where each job has a deadline and a profit if the job is completed before its deadline. Each job takes 1 unit of time. Schedule the jobs to maximize total profit, ensuring no two jobs overlap.\\n\\n---\\n\\n#### **Formulation**\\n\\n1. **Sort Jobs by Profit**  \\n   Prioritize jobs with higher profit.\\n\\n2. **State Representation**  \\n   Use a timeline (array) to track available slots for scheduling.\\n\\n3. **Algorithm**  \\n   For each job, try to schedule it in the latest possible slot before its deadline. Use a greedy approach combined with DP-like memory management.\\n\\n---\\n\\n#### **Implementation**\\n\\n**Java Code:**\\n```java\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\n\\npublic class JobScheduling {\\n    static class Job {\\n        int id, deadline, profit;\\n\\n        Job(int id, int deadline, int profit) {\\n            this.id = id;\\n            this.deadline = deadline;\\n            this.profit = profit;\\n        }\\n    }\\n\\n    public static int maxProfit(Job[] jobs) {\\n        // Sort jobs by profit in descending order\\n        Arrays.sort(jobs, (a, b) -> b.profit - a.profit);\\n\\n        int maxDeadline = Arrays.stream(jobs).mapToInt(job -> job.deadline).max().orElse(0);\\n        int[] slots = new int[maxDeadline + 1]; // Track free slots\\n        Arrays.fill(slots, -1);\\n\\n        int totalProfit = 0;\\n\\n        // Schedule jobs\\n        for (Job job : jobs) {\\n            for (int i = job.deadline; i > 0; i--) {\\n                if (slots[i] == -1) {\\n                    slots[i] = job.id; // Assign job to this slot\\n                    totalProfit += job.profit;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return totalProfit;\\n    }\\n\\n    public static void main(String[] args) {\\n        Job[] jobs = {\\n            new Job(1, 4, 20),\\n            new Job(2, 1, 10),\\n            new Job(3, 1, 40),\\n            new Job(4, 1, 30)\\n        };\\n\\n        System.out.println(\\"Maximum Profit: \\" + maxProfit(jobs)); // Output: 60\\n    }\\n}\\n```\\n\\n---\\n\\n### **2. Game Theory with Minimax and DP**\\n\\n#### **Problem Statement**\\nTwo players play a game where they take turns picking numbers from either end of an array. The goal is to maximize your score. Determine the maximum score the first player can achieve assuming both players play optimally.\\n\\n---\\n\\n#### **Formulation**\\n\\n1. **State Representation**  \\n   $ dp[i][j] $: The maximum score the current player can achieve from the subarray $ nums[i] $ to $ nums[j] $.\\n\\n2. **Recurrence Relation**  \\n   At each turn, the current player picks from either end:  \\n   $$\\n   dp[i][j] = \\\\max(nums[i] + \\\\min(dp[i+2][j], dp[i+1][j-1]),\\n   nums[j] + \\\\min(dp[i+1][j-1], dp[i][j-2]))\\n   $$\\n\\n3. **Base Case**  \\n   $ dp[i][i] = nums[i] $: If there\u2019s only one element, that\u2019s the score.\\n\\n---\\n\\n#### **Implementation**\\n\\n**Java Code:**\\n```java\\npublic class OptimalGameStrategy {\\n    public static int maxScore(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n\\n        // Base case: Single element\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\n        // Fill DP table diagonally\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n - length; i++) {\\n                int j = i + length - 1;\\n                int pickLeft = nums[i] + Math.min((i + 2 <= j ? dp[i + 2][j] : 0), \\n                                                  (i + 1 <= j - 1 ? dp[i + 1][j - 1] : 0));\\n                int pickRight = nums[j] + Math.min((i <= j - 2 ? dp[i][j - 2] : 0), \\n                                                   (i + 1 <= j - 1 ? dp[i + 1][j - 1] : 0));\\n                dp[i][j] = Math.max(pickLeft, pickRight);\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 5, 233, 7};\\n        System.out.println(\\"Maximum score: \\" + maxScore(nums)); // Output: 236\\n    }\\n}\\n```\\n\\n---\\n\\n### **3. Real-World Applications Overview**\\n\\n#### **Scheduling Problems**\\n- **Use Case**: Airline crew scheduling, task scheduling in operating systems.\\n- **Approach**: Greedy + DP (e.g., Job Scheduling above).\\n\\n#### **Game Theory**\\n- **Use Case**: Chess, Nim, Poker.\\n- **Approach**: Minimax + DP for computational efficiency.\\n\\n#### **Dynamic Pricing**\\n- **Use Case**: E-commerce platforms, airlines.\\n- **Approach**: Multi-stage DP to decide optimal pricing strategy for maximum revenue.\\n\\n#### **Resource Allocation**\\n- **Use Case**: Cloud resource management, manufacturing.\\n- **Approach**: DP-based knapsack or scheduling solutions.\\n\\n---\\n\\n### **Advanced Dynamic Programming Concepts**\\n\\nDynamic Programming (DP) becomes even more powerful with advanced techniques and optimizations tailored to handle more complex problems efficiently. In this section, we will discuss:\\n\\n1. **Policy-Based Optimization** (e.g., Knuth Optimization and Divide-and-Conquer DP).\\n2. **Approximation Techniques** (e.g., Dynamic Relaxation for NP-hard problems).\\n3. **Real-World Problem Challenges** (e.g., examples from competitive programming platforms).\\n\\n---\\n\\n### **1. Policy-Based Optimization**\\n\\n#### **1.1 Knuth Optimization**\\n\\nKnuth Optimization is used to optimize problems where the recurrence relation involves a range of indices. For example, consider splitting a string or merging files to minimize cost.\\n\\n##### **Problem Statement**\\nGiven an array $ arr[] $, find the minimum cost of merging $ arr[i...j] $ into a single element, where the cost of merging is proportional to the sum of the elements involved.\\n\\n---\\n\\n##### **Key Idea**\\nKnuth Optimization states that if $ dp[i][k] + dp[k+1][j] $ is minimized by some $ k $, then $ k $ for $ dp[i][j-1] $ will not exceed $ k $ for $ dp[i][j] $. This observation reduces the complexity from $ O(n^3) $ to $ O(n^2) $.\\n\\n---\\n\\n##### **Implementation**\\n\\n**Java Code:**\\n```java\\npublic class KnuthOptimization {\\n    public static int minMergeCost(int[] arr) {\\n        int n = arr.length;\\n        int[][] dp = new int[n][n];\\n        int[][] opt = new int[n][n];\\n        int[] prefixSum = new int[n + 1];\\n\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i + 1] = prefixSum[i] + arr[i];\\n            opt[i][i] = i;\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                dp[i][j] = Integer.MAX_VALUE;\\n\\n                for (int k = opt[i][j - 1]; k <= opt[i + 1][j]; k++) {\\n                    int cost = dp[i][k] + dp[k + 1][j] + prefixSum[j + 1] - prefixSum[i];\\n                    if (cost < dp[i][j]) {\\n                        dp[i][j] = cost;\\n                        opt[i][j] = k;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {10, 20, 30};\\n        System.out.println(\\"Minimum Merge Cost: \\" + minMergeCost(arr)); // Output: 90\\n    }\\n}\\n```\\n\\n---\\n\\n#### **1.2 Divide-and-Conquer DP**\\n\\nDivide-and-Conquer DP is another optimization technique that reduces the state space complexity by leveraging a specific property of the recurrence relation, often in problems involving matrix multiplication, range queries, or convex hulls.\\n\\n##### **Problem Example**:\\nFind the minimum cost of cutting a stick into pieces of given lengths.\\n\\n---\\n\\n### **2. Approximation Techniques**\\n\\nSome problems are so complex (NP-hard) that exact DP solutions are infeasible. In such cases, **approximation techniques** combined with DP can provide solutions close to optimal.\\n\\n#### **Example: Traveling Salesman Problem (TSP)**\\n\\n---\\n\\n**Approximation with Dynamic Relaxation**:\\n1. Solve a simplified version of TSP using DP.\\n2. Gradually add constraints to refine the solution.\\n\\n**Java Code (DP for Simplified TSP):**\\n```java\\nimport java.util.Arrays;\\n\\npublic class TSPApproximation {\\n    public static int tsp(int[][] graph) {\\n        int n = graph.length;\\n        int[][] dp = new int[1 << n][n];\\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        dp[1][0] = 0;\\n\\n        for (int mask = 1; mask < (1 << n); mask++) {\\n            for (int u = 0; u < n; u++) {\\n                if ((mask & (1 << u)) != 0) {\\n                    for (int v = 0; v < n; v++) {\\n                        if ((mask & (1 << v)) == 0) {\\n                            dp[mask | (1 << v)][v] = Math.min(dp[mask | (1 << v)][v],\\n                                                              dp[mask][u] + graph[u][v]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int minCost = Integer.MAX_VALUE;\\n        for (int i = 1; i < n; i++) {\\n            minCost = Math.min(minCost, dp[(1 << n) - 1][i] + graph[i][0]);\\n        }\\n        return minCost;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[][] graph = {\\n            {0, 10, 15, 20},\\n            {10, 0, 35, 25},\\n            {15, 35, 0, 30},\\n            {20, 25, 30, 0}\\n        };\\n        System.out.println(\\"TSP Approximation Cost: \\" + tsp(graph)); // Output: 80\\n    }\\n}\\n```\\n\\n---\\n\\n### **3. Real-World Competitive Challenges**\\n\\n#### **Example 1: Google Kick Start - Painting Fence**\\n**Problem**: Given $ n $ fence posts and $ k $ colors, calculate the number of ways to paint the fence such that no more than two adjacent posts have the same color.\\n\\n##### **DP Solution**:\\n- $ dp[i][0] $: Ways to paint the $ i $-th post differently from $ i-1 $.\\n- $ dp[i][1] $: Ways to paint the $ i $-th post the same as $ i-1 $.\\n\\n**Java Code:**\\n```java\\npublic class PaintingFence {\\n    public static int numWays(int n, int k) {\\n        if (n == 0) return 0;\\n        if (n == 1) return k;\\n\\n        int same = k, diff = k * (k - 1);\\n\\n        for (int i = 3; i <= n; i++) {\\n            int prevDiff = diff;\\n            diff = (same + diff) * (k - 1);\\n            same = prevDiff;\\n        }\\n\\n        return same + diff;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 3, k = 2;\\n        System.out.println(\\"Number of ways to paint: \\" + numWays(n, k)); // Output: 6\\n    }\\n}\\n```\\n\\n---\\n\\n### **Hybrid approaches**\\n\\nIn the upcoming section, we will dive deeper into **hybrid approaches** that combine **Dynamic Programming (DP)** with other algorithmic techniques to tackle complex problems. These hybrid approaches are crucial in solving real-world challenges, especially in environments where there are **multiple constraints** or **high computational demands**. We\'ll explore the following concepts:\\n\\n1. **Combining Greedy Algorithms with DP**  \\n   Greedy algorithms often make locally optimal choices to reach a global optimum. However, there are cases where a pure greedy approach does not guarantee the optimal solution, and this is where **DP** can step in to refine the greedy approach by considering future consequences and ensuring that the global solution is optimal.\\n\\n2. **Multi-Dimensional DP**  \\n   Many problems involve multiple constraints or variables, which can\'t be solved using a simple one-dimensional DP array. We\u2019ll explore **multi-dimensional DP** techniques that allow us to model more complex state spaces. These problems often involve multiple parameters that need to be optimized simultaneously, like pathfinding problems with additional constraints or scheduling problems.\\n\\n3. **Solving Interactive Problems**  \\n   Some problems require **interactive solutions**, where the algorithm has to interact with an external system or dynamically adjust its decisions based on real-time input. We\'ll explore how DP can be combined with strategies to handle these dynamic environments.\\n\\n### **Let\u2019s Explore These Concepts in Detail:**\\n\\n---\\n\\n#### **1. Combining Greedy Algorithms with DP**\\n\\nGreedy algorithms are designed to make the best local choice at each step in the hope of finding the global optimum. While this works for many problems, in some cases, a greedy approach doesn\'t guarantee an optimal solution. In such cases, combining **greedy algorithms** with **Dynamic Programming** can refine the solution by taking into account the broader problem context.\\n\\n##### **Example: Job Scheduling Problem**\\n\\n**Problem:**  \\nYou are given a set of jobs, each with a start time, finish time, and profit. The goal is to select the maximum set of non-overlapping jobs that maximize the profit.\\n\\n- **Greedy Approach:**  \\n  One greedy approach might involve sorting jobs based on their finish times and selecting the ones that don\u2019t overlap. This can work in certain cases, but it\'s not guaranteed to find the optimal solution if there are situations where non-overlapping jobs have lower profits, but the overall combination results in higher profits.\\n\\n- **DP Approach:**  \\n  By using DP, we can combine the greedy approach with an optimal selection strategy, where we recursively calculate the maximum profit considering both the current job and all previously selected jobs, ensuring we maximize the profit globally.\\n\\n##### **Hybrid Solution (Greedy + DP):**\\nWe\'ll first sort the jobs based on finish time and then use **Dynamic Programming** to store the maximum profit for each subset of jobs.\\n\\n##### **Java Code for Job Scheduling Problem (Greedy + DP)**\\n\\n```java\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\n\\npublic class JobScheduling {\\n\\n    static class Job {\\n        int start, finish, profit;\\n\\n        Job(int start, int finish, int profit) {\\n            this.start = start;\\n            this.finish = finish;\\n            this.profit = profit;\\n        }\\n    }\\n\\n    // Function to find the last job that doesn\'t conflict with the current job\\n    static int findLastNonConflict(Job[] jobs, int n) {\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (jobs[i].finish <= jobs[n].start) {\\n                return i;\\n            }\\n        }\\n        return -1; // No job found\\n    }\\n\\n    // Function to schedule the jobs for maximum profit\\n    static int findMaxProfit(Job[] jobs, int n) {\\n        // Sort jobs according to their finish time\\n        Arrays.sort(jobs, Comparator.comparingInt(job -> job.finish));\\n\\n        // DP array to store results of subproblems\\n        int[] dp = new int[n];\\n        dp[0] = jobs[0].profit;\\n\\n        // Fill the dp array by checking each job\\n        for (int i = 1; i < n; i++) {\\n            // Include the current job\\n            int inclProfit = jobs[i].profit;\\n            int l = findLastNonConflict(jobs, i);\\n            if (l != -1) {\\n                inclProfit += dp[l];\\n            }\\n\\n            // Exclude the current job\\n            int exclProfit = dp[i - 1];\\n\\n            // Take the maximum of including or excluding the current job\\n            dp[i] = Math.max(inclProfit, exclProfit);\\n        }\\n\\n        return dp[n - 1]; // Return the maximum profit\\n    }\\n\\n    public static void main(String[] args) {\\n        // Jobs (start time, finish time, profit)\\n        Job[] jobs = {\\n            new Job(1, 3, 50),\\n            new Job(3, 5, 20),\\n            new Job(6, 19, 100),\\n            new Job(2, 100, 200)\\n        };\\n        int n = jobs.length;\\n\\n        System.out.println(\\"Maximum Profit: \\" + findMaxProfit(jobs, n)); // Output: 250\\n    }\\n}\\n```\\n\\n---\\n\\n### **Explanation of Code:**\\n\\n1. **Job Class:**  \\n   Each job is represented by a start time, finish time, and profit.\\n\\n2. **Sort Jobs:**  \\n   The jobs are sorted based on their finish times. This step is inspired by the greedy approach, which selects jobs that finish the earliest to maximize room for subsequent jobs.\\n\\n3. **Dynamic Programming:**  \\n   The `dp[]` array stores the maximum profit achievable up to each job. For each job, we decide whether to include it in the optimal schedule or exclude it, comparing the profit from both choices.\\n\\n4. **Find Last Non-Conflict Job:**  \\n   The function `findLastNonConflict()` searches for the latest job that doesn\u2019t overlap with the current job. This allows us to combine jobs optimally.\\n\\n---\\n\\n### **Time Complexity:**\\n\\n- **Time Complexity:**  \\n  Sorting the jobs takes $ O(n \\\\log n) $, and for each job, we perform a linear search to find the last non-conflicting job, resulting in an overall time complexity of $ O(n^2) $. We can optimize this further using binary search to find the last non-conflicting job, reducing the complexity to $ O(n \\\\log n) $.\\n\\n- **Space Complexity:**  \\n  The space complexity is $ O(n) $ due to the DP table.\\n\\n---\\n\\n#### **2. Multi-Dimensional DP**\\n\\nFor more complex problems that involve multiple variables or constraints, **multi-dimensional DP** is an effective technique. It expands the concept of a single DP table to include multiple dimensions (arrays), where each dimension represents a different aspect of the problem\u2019s state.\\n\\n##### **Example: Knapsack Problem with Multiple Constraints**\\n\\n**Problem:**  \\nYou have a knapsack with a weight limit, and you also need to consider additional constraints such as volume or cost.\\n\\n- **State Representation:**  \\n  $ dp[w][v] $ where $ w $ represents the weight, and $ v $ represents the volume (or any other constraint).\\n\\n##### **Java Code for Multi-Dimensional Knapsack Problem:**\\n```java\\npublic class MultiDimensionalKnapsack {\\n    public static int knapsack(int[] weights, int[] values, int W, int V) {\\n        int n = weights.length;\\n        int[][] dp = new int[W + 1][V + 1];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int w = W; w >= weights[i]; w--) {\\n                for (int v = V; v >= 1; v--) {\\n                    dp[w][v] = Math.max(dp[w][v], dp[w - weights[i]][v - 1] + values[i]);\\n                }\\n            }\\n        }\\n        return dp[W][V];\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] weights = {1, 2, 3};\\n        int[] values = {10, 20, 30};\\n        int W = 4;\\n        int V = 2;\\n        System.out.println(\\"Maximum value in knapsack: \\" + knapsack(weights, values, W, V));\\n    }\\n}\\n```\\n\\n---\\n\\n#### **3. Solving Interactive Problems with DP**\\n\\nSome problems, such as games or scenarios requiring **real-time decisions**, may need to incorporate **interactive feedback** or dynamic adjustments. In such cases, the algorithm must constantly adjust its state based on external inputs or outputs, and this is where **DP** can be powerful.\\n\\n##### **Example: Interactive Game Theory Problem (Nim Game)**\\n\\n**Problem:**  \\nIn the Nim game, two players take turns removing stones from a pile. Each player can take between 1 and $ k $ stones on their turn, and the player who takes the last stone wins. We need to decide the best move at each stage.\\n\\n- **DP Solution:**  \\n  We can use DP to decide the optimal move for any given number of stones left. The state of the game (number of stones left) and the current player can be modeled using a DP array.\\n\\n##### **Java Code (Nim Game with DP):**\\n```java\\npublic class NimGame {\\n    public static boolean canWinNim(int n, int k) {\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = false;  // If there are no stones left, the current player loses\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int x = 1\\n\\n; x <= Math.min(k, i); x++) {\\n                if (!dp[i - x]) {  // If there\'s a move that leaves the opponent with a losing state\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];  // If the current player can win starting with n stones\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 7; // Number of stones\\n        int k = 3; // Maximum stones that can be removed per turn\\n        System.out.println(\\"Can win Nim: \\" + canWinNim(n, k));  // Output: true\\n    }\\n}\\n```\\n\\n---"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.465,"hasTruncateMarker":true,"authors":[{"name":"S\xe9bastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","imageURL":"https://github.com/yangshun.png","key":"yangshun","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"Dynamic Programing","permalink":"/blog/test"},"nextItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\\n\\nHere are a few tips you might find useful.\\n\\n\x3c!-- truncate --\x3e\\n\\nSimply add Markdown files (or folders) to the `blog` directory.\\n\\nRegular blog authors can be added to `authors.yml`.\\n\\nThe blog post date can be extracted from filenames, such as:\\n\\n- `2019-05-30-welcome.md`\\n- `2019-05-30-welcome/index.md`\\n\\nA blog post folder can be convenient to co-locate blog post images:\\n\\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\\n\\nThe blog supports tags as well!\\n\\n**And if you don\'t want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."},{"id":"mdx-blog-post","metadata":{"permalink":"/blog/mdx-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-01-mdx-blog-post.mdx","source":"@site/blog/2021-08-01-mdx-blog-post.mdx","title":"MDX Blog Post","description":"Blog posts support Docusaurus Markdown features, such as MDX.","date":"2021-08-01T00:00:00.000Z","tags":[{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.235,"hasTruncateMarker":true,"authors":[{"name":"S\xe9bastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"}],"frontMatter":{"slug":"mdx-blog-post","title":"MDX Blog Post","authors":["slorber"],"tags":["docusaurus"]},"unlisted":false,"prevItem":{"title":"Welcome","permalink":"/blog/welcome"},"nextItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).\\n\\n:::tip\\n\\nUse the power of React to create interactive blog posts.\\n\\n:::\\n\\n{/* truncate */}\\n\\nFor example, use JSX to create an interactive button:\\n\\n```js\\n<button onClick={() => alert(\'button clicked!\')}>Click me!</button>\\n```\\n\\n<button onClick={() => alert(\'button clicked!\')}>Click me!</button>"},{"id":"long-blog-post","metadata":{"permalink":"/blog/long-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-long-blog-post.md","source":"@site/blog/2019-05-29-long-blog-post.md","title":"Long Blog Post","description":"This is the summary of a very long blog post,","date":"2019-05-29T00:00:00.000Z","tags":[{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":2.06,"hasTruncateMarker":true,"authors":[{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","imageURL":"https://github.com/yangshun.png","key":"yangshun","page":null}],"frontMatter":{"slug":"long-blog-post","title":"Long Blog Post","authors":"yangshun","tags":["hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"},"nextItem":{"title":"First Blog Post","permalink":"/blog/first-blog-post"}},"content":"This is the summary of a very long blog post,\\n\\nUse a `\x3c!--` `truncate` `--\x3e` comment to limit blog post size in the list view.\\n\\n\x3c!-- truncate --\x3e\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"},{"id":"first-blog-post","metadata":{"permalink":"/blog/first-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-28-first-blog-post.md","source":"@site/blog/2019-05-28-first-blog-post.md","title":"First Blog Post","description":"Lorem ipsum dolor sit amet...","date":"2019-05-28T00:00:00.000Z","tags":[{"inline":false,"label":"Hola","permalink":"/blog/tags/hola","description":"Hola tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.135,"hasTruncateMarker":true,"authors":[{"name":"S\xe9bastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Front End Engineer @ Facebook","url":"https://github.com/yangshun","imageURL":"https://github.com/yangshun.png","key":"yangshun","page":null}],"frontMatter":{"slug":"first-blog-post","title":"First Blog Post","authors":["slorber","yangshun"],"tags":["hola","docusaurus"]},"unlisted":false,"prevItem":{"title":"Long Blog Post","permalink":"/blog/long-blog-post"}},"content":"Lorem ipsum dolor sit amet...\\n\\n\x3c!-- truncate --\x3e\\n\\n...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet"}]}}')}}]);