"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[6537],{839:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Tree/iterative-binary-tree-traversal","title":"Iterative binary tree traversal","description":"To perform an iterative inorder traversal of a Binary Search Tree (BST), we can use a stack to simulate the recursive call stack.","source":"@site/docs/Tree/iterative-binary-tree-traversal.md","sourceDirName":"Tree","slug":"/Tree/iterative-binary-tree-traversal","permalink":"/docs/Tree/iterative-binary-tree-traversal","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/docs/Tree/iterative-binary-tree-traversal.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Previous larger/smaller element","permalink":"/docs/Stack/Monotonic Stack/previous-larger-or-smaller-element"}}');var s=t(4848),i=t(8453);const o={},l="Iterative binary tree traversal",a={},c=[{value:"<strong>Steps for Iterative Inorder Traversal</strong>:",id:"steps-for-iterative-inorder-traversal",level:3},{value:"<strong>Python Code for Iterative Inorder Traversal</strong>:",id:"python-code-for-iterative-inorder-traversal",level:3},{value:"<strong>Explanation</strong>:",id:"explanation",level:3},{value:"<strong>Dry Run</strong>:",id:"dry-run",level:3},{value:"<strong>Time Complexity</strong>:",id:"time-complexity",level:3},{value:"<strong>Space Complexity</strong>:",id:"space-complexity",level:3}];function d(e){const r={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"iterative-binary-tree-traversal",children:"Iterative binary tree traversal"})}),"\n",(0,s.jsxs)(r.p,{children:["To perform an ",(0,s.jsx)(r.strong,{children:"iterative inorder traversal"})," of a Binary Search Tree (BST), we can use a stack to simulate the recursive call stack."]}),"\n",(0,s.jsxs)(r.h3,{id:"steps-for-iterative-inorder-traversal",children:[(0,s.jsx)(r.strong,{children:"Steps for Iterative Inorder Traversal"}),":"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Initialize a stack"})," to keep track of nodes."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Traverse the left subtree"}),": Move down the left child of the current node, pushing all left children onto the stack."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Visit the node"}),": Once there are no more left children, pop from the stack and process the node."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Traverse the right subtree"}),": After processing the current node, move to its right child and repeat the process."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"python-code-for-iterative-inorder-traversal",children:[(0,s.jsx)(r.strong,{children:"Python Code for Iterative Inorder Traversal"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode):\n        stack = []\n        result = []\n        current = root\n\n        while current or stack:\n            # Go to the leftmost node and push all the nodes on the path to stack\n            while current:\n                stack.append(current)\n                current = current.left\n\n            # Pop the node from the stack and visit it\n            current = stack.pop()\n            result.append(current.val)\n\n            # Move to the right subtree\n            current = current.right\n\n        return result\n"})}),"\n",(0,s.jsxs)(r.h3,{id:"explanation",children:[(0,s.jsx)(r.strong,{children:"Explanation"}),":"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"While loop"}),": Continue as long as the ",(0,s.jsx)(r.code,{children:"current"})," node is not ",(0,s.jsx)(r.code,{children:"None"})," or the stack is not empty."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Push left nodes"}),": Traverse as far left as possible, pushing each node to the stack."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Visit nodes"}),": Pop from the stack and append the value to the result list."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Move to right subtree"}),": After visiting a node, move to its right child."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"dry-run",children:[(0,s.jsx)(r.strong,{children:"Dry Run"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"For a BST like this:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"      4\n     / \\\n    2   6\n   / \\ / \\\n  1  3 5  7\n"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Start with ",(0,s.jsx)(r.code,{children:"root = 4"}),"."]}),"\n",(0,s.jsxs)(r.li,{children:["Move left to ",(0,s.jsx)(r.code,{children:"2"}),", then to ",(0,s.jsx)(r.code,{children:"1"}),", and push the nodes onto the stack."]}),"\n",(0,s.jsxs)(r.li,{children:["Pop ",(0,s.jsx)(r.code,{children:"1"}),", visit it, then move back to ",(0,s.jsx)(r.code,{children:"2"})," and visit it."]}),"\n",(0,s.jsxs)(r.li,{children:["Move to ",(0,s.jsx)(r.code,{children:"3"}),", visit it, then move back to ",(0,s.jsx)(r.code,{children:"4"})," and visit it."]}),"\n",(0,s.jsxs)(r.li,{children:["Move right to ",(0,s.jsx)(r.code,{children:"6"}),", then to ",(0,s.jsx)(r.code,{children:"5"}),", visit ",(0,s.jsx)(r.code,{children:"5"}),", then ",(0,s.jsx)(r.code,{children:"6"}),", and finally visit ",(0,s.jsx)(r.code,{children:"7"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Result: ",(0,s.jsx)(r.code,{children:"[1, 2, 3, 4, 5, 6, 7]"}),"."]}),"\n",(0,s.jsxs)(r.h3,{id:"time-complexity",children:[(0,s.jsx)(r.strong,{children:"Time Complexity"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"O(n)"}),": Each node is visited once."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"space-complexity",children:[(0,s.jsx)(r.strong,{children:"Space Complexity"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"O(h)"}),": The stack stores the path from the current node to the leftmost node, where ",(0,s.jsx)(r.code,{children:"h"})," is the height of the tree. In the worst case (unbalanced tree), it will be ",(0,s.jsx)(r.code,{children:"O(n)"}),". For a balanced tree, it's ",(0,s.jsx)(r.code,{children:"O(log n)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"This approach avoids recursion while still following the left-root-right traversal order, which is the essence of inorder traversal."})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>l});var n=t(6540);const s={},i=n.createContext(s);function o(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);