"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[7473],{6314:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Miscleneous/line-sweep","title":"Line Sweep: A Logical Overview","description":"The Line Sweep Algorithm is a powerful technique used to efficiently solve problems involving ranges, intervals, or events that occur in a linear order. It\u2019s commonly applied in computational geometry, scheduling problems, and range-based data analysis.","source":"@site/docs/Miscleneous/line-sweep.md","sourceDirName":"Miscleneous","slug":"/Miscleneous/line-sweep","permalink":"/docs/Miscleneous/line-sweep","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/docs/Miscleneous/line-sweep.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Maximum Score from Performing Multiplication Operations","permalink":"/docs/Dynamic Programming/Questions/maximum-score-from-mul-ops"},"next":{"title":"Next Smaller/Larger Element","permalink":"/docs/Stack/Monotonic Stack/next-larger-or-smaller-element"}}');var r=i(4848),l=i(8453);const t={},o="Line Sweep: A Logical Overview",a={},c=[{value:"<strong>Core Concept</strong>",id:"core-concept",level:3},{value:"<strong>Key Features</strong>",id:"key-features",level:3},{value:"<strong>Applications of Line Sweep</strong>",id:"applications-of-line-sweep",level:3},{value:"<strong>Example: Range Update Using Line Sweep</strong>",id:"example-range-update-using-line-sweep",level:3},{value:"Naive Approach:",id:"naive-approach",level:4},{value:"Line Sweep Solution:",id:"line-sweep-solution",level:4},{value:"<strong>Code Example</strong>",id:"code-example",level:3},{value:"<strong>Benefits of Line Sweep</strong>",id:"benefits-of-line-sweep",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"line-sweep-a-logical-overview",children:"Line Sweep: A Logical Overview"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Line Sweep Algorithm"})," is a powerful technique used to efficiently solve problems involving ranges, intervals, or events that occur in a linear order. It\u2019s commonly applied in computational geometry, scheduling problems, and range-based data analysis."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"core-concept",children:(0,r.jsx)(n.strong,{children:"Core Concept"})}),"\n",(0,r.jsx)(n.p,{children:"The idea behind line sweep is simple:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mark Events"}),": Identify key points where something starts or ends (e.g., the start or end of a range or interval)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sort Events (if needed)"}),": Order these events by their position or time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Process Events Sequentially"}),": Sweep through the events, maintaining a running state (like an active count of ranges, cumulative values, etc.), and use this to answer queries or compute results."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:(0,r.jsx)(n.strong,{children:"Key Features"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Event Marking"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"For each range or interval, mark the start and end points with appropriate values (e.g., +1 for a start, -1 for an end)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cumulative Calculation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"As you process the events, maintain a running total or state that reflects the active effects at each position."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Efficiency"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Instead of iterating over ranges repeatedly, line sweep processes all events in a single pass (or after sorting), often reducing complexity from (O(n^2)) to (O(n \\log n)) or (O(n))."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"applications-of-line-sweep",children:(0,r.jsx)(n.strong,{children:"Applications of Line Sweep"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Counting Overlapping Intervals"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Problem: Find how many intervals overlap at any given point."}),"\n",(0,r.jsx)(n.li,{children:"Solution: Mark starts with +1 and ends with -1, then use a running total to count active intervals."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Range Updates"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Problem: Apply multiple range-based modifications to an array efficiently."}),"\n",(0,r.jsxs)(n.li,{children:["Solution: Use a ",(0,r.jsx)(n.strong,{children:"difference array"})," to mark the effects of each range and compute the result with a prefix sum."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Computational Geometry"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Example: Finding intersections of line segments or calculating the union area of rectangles."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"example-range-update-using-line-sweep",children:(0,r.jsx)(n.strong,{children:"Example: Range Update Using Line Sweep"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Increment all elements in an array ",(0,r.jsx)(n.code,{children:"arr"})," within several given ranges ([l, r])."]}),"\n",(0,r.jsx)(n.h4,{id:"naive-approach",children:"Naive Approach:"}),"\n",(0,r.jsx)(n.p,{children:"For each range, increment the elements in that range:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"(O(n \\times q)) for (q) queries on an array of size (n)."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"line-sweep-solution",children:"Line Sweep Solution:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Create a ",(0,r.jsx)(n.strong,{children:"difference array"})," ",(0,r.jsx)(n.code,{children:"diff"})," of size (n + 1)."]}),"\n",(0,r.jsxs)(n.li,{children:["For each range ([l, r]):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Increment ",(0,r.jsx)(n.code,{children:"diff[l]"})," by 1."]}),"\n",(0,r.jsxs)(n.li,{children:["Decrement ",(0,r.jsx)(n.code,{children:"diff[r + 1]"})," by 1."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Compute the prefix sum of ",(0,r.jsx)(n.code,{children:"diff"})," to get the final modified array in (O(n))."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": (O(n + q))."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"code-example",children:(0,r.jsx)(n.strong,{children:"Code Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def apply_range_updates(n, queries):\n    diff = [0] * (n + 1)\n    \n    # Mark the ranges\n    for l, r in queries:\n        diff[l] += 1\n        if r + 1 < n:\n            diff[r + 1] -= 1\n    \n    # Compute the final array using prefix sum\n    result = [0] * n\n    current = 0\n    for i in range(n):\n        current += diff[i]\n        result[i] = current\n    \n    return result\n\n# Example Usage\nn = 5\nqueries = [(0, 2), (1, 4)]\nprint(apply_range_updates(n, queries))  # Output: [1, 2, 2, 1, 1]\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-line-sweep",children:(0,r.jsx)(n.strong,{children:"Benefits of Line Sweep"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Handles large datasets efficiently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexibility"}),": Adapts to various problems involving ranges or intervals."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Elegant Logic"}),": Focuses on key events, avoiding unnecessary computations."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Line sweep is a go-to technique whenever you deal with ",(0,r.jsx)(n.strong,{children:"interval-based problems"})," or need to ",(0,r.jsx)(n.strong,{children:"aggregate effects over ranges"})," efficiently."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var s=i(6540);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);