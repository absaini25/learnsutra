"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[3403],{6416:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"Technology Deep Dives/cassandra","title":"Cassandra: Deep Dive","description":"Cassandra Architecture: Tunable Consistency Explained","source":"@site/system-design/Technology Deep Dives/cassandra.md","sourceDirName":"Technology Deep Dives","slug":"/Technology Deep Dives/cassandra","permalink":"/system-design/Technology Deep Dives/cassandra","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/edit/main/system-design/Technology Deep Dives/cassandra.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Distributed locking via Redis","permalink":"/system-design/Distributed Systems Nuances/distributed-locking"},"next":{"title":"Important numbers for system design","permalink":"/system-design/important-numbers"}}');var r=s(4848),l=s(8453);const t={},c="Cassandra: Deep Dive",a={},o=[{value:"Cassandra Architecture: Tunable Consistency Explained",id:"cassandra-architecture-tunable-consistency-explained",level:3},{value:"<strong>What is Tunable Consistency?</strong>",id:"what-is-tunable-consistency",level:4},{value:"<strong>Cassandra\u2019s Consistency Levels</strong>",id:"cassandras-consistency-levels",level:4},{value:"<strong>How Cassandra Achieves Tunable Consistency</strong>",id:"how-cassandra-achieves-tunable-consistency",level:4},{value:"<strong>Trade-offs in Tunable Consistency</strong>",id:"trade-offs-in-tunable-consistency",level:4},{value:"<strong>Use Cases and Best Practices</strong>",id:"use-cases-and-best-practices",level:4},{value:"<strong>Conclusion</strong>",id:"conclusion",level:4}];function d(e){const n={h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"cassandra-deep-dive",children:"Cassandra: Deep Dive"})}),"\n",(0,r.jsx)(n.h3,{id:"cassandra-architecture-tunable-consistency-explained",children:"Cassandra Architecture: Tunable Consistency Explained"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Cassandra is a distributed NoSQL database inspired by Amazon\u2019s DynamoDB and Google\u2019s Bigtable. One of its core strengths is ",(0,r.jsx)(n.strong,{children:"tunable consistency"}),", which allows developers to balance between consistency, availability, and latency based on their use case. Here, we\u2019ll dive into how Cassandra achieves tunable consistency and its implications in a distributed system."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"what-is-tunable-consistency",children:(0,r.jsx)(n.strong,{children:"What is Tunable Consistency?"})}),"\n",(0,r.jsx)(n.p,{children:"Tunable consistency is the ability to configure how strongly or weakly consistent read and write operations are in a distributed system. Cassandra allows you to define consistency levels per query, giving you control over the trade-offs between:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency"}),": Ensuring all replicas have the same data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Availability"}),": Keeping the system operational even under failures."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Latency"}),": The time taken to complete a read or write operation."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This flexibility is based on the ",(0,r.jsx)(n.strong,{children:"CAP theorem"}),", which states that a distributed system can provide at most two out of the following three guarantees:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency"}),": Every read receives the most recent write."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Availability"}),": Every request receives a response, even if some replicas are down."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Partition Tolerance"}),": The system continues to function despite network partitions."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"cassandras-consistency-levels",children:(0,r.jsx)(n.strong,{children:"Cassandra\u2019s Consistency Levels"})}),"\n",(0,r.jsxs)(n.p,{children:["Cassandra provides several consistency levels for both ",(0,r.jsx)(n.strong,{children:"reads"})," and ",(0,r.jsx)(n.strong,{children:"writes"}),". These levels determine how many replicas must respond for an operation to be considered successful."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistency Levels for Writes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ANY"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A write is successful if at least one node (including a hinted handoff) acknowledges the write."}),"\n",(0,r.jsx)(n.li,{children:"Provides the lowest consistency but ensures maximum availability."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ONE"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A write is successful if at least one replica acknowledges it."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"QUORUM"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A majority of replicas (i.e., more than half) must acknowledge the write."}),"\n",(0,r.jsx)(n.li,{children:"Balances consistency and availability."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LOCAL_QUORUM"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A majority of replicas in the local data center must acknowledge the write."}),"\n",(0,r.jsx)(n.li,{children:"Ideal for multi-data center setups."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ALL"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All replicas must acknowledge the write."}),"\n",(0,r.jsx)(n.li,{children:"Ensures the highest consistency but sacrifices availability."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistency Levels for Reads"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ONE"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The query returns the data from the first replica to respond."}),"\n",(0,r.jsx)(n.li,{children:"May return stale data but provides the lowest latency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TWO"})," or ",(0,r.jsx)(n.strong,{children:"THREE"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The query waits for responses from two or three replicas, respectively."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"QUORUM"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A majority of replicas must respond."}),"\n",(0,r.jsx)(n.li,{children:"Ensures stronger consistency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LOCAL_QUORUM"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A majority of replicas in the local data center must respond."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ALL"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All replicas must respond before returning data."}),"\n",(0,r.jsx)(n.li,{children:"Ensures the highest consistency but increases latency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SERIAL"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Used with lightweight transactions to ensure linearizable consistency."}),"\n",(0,r.jsx)(n.li,{children:"Ensures no conflicting updates."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LOCAL_SERIAL"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Similar to SERIAL but confined to the local data center."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"how-cassandra-achieves-tunable-consistency",children:(0,r.jsx)(n.strong,{children:"How Cassandra Achieves Tunable Consistency"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Replication Factor"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The number of copies of data maintained across the cluster."}),"\n",(0,r.jsx)(n.li,{children:"Higher replication factors improve fault tolerance but increase storage requirements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistency Level vs. Replication Factor"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Consistency is determined by the combination of ",(0,r.jsx)(n.strong,{children:"replication factor"})," and ",(0,r.jsx)(n.strong,{children:"consistency level"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Replication Factor = 3"}),"\n",(0,r.jsx)(n.li,{children:"Consistency Level = QUORUM (requires 2 replicas to respond)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hinted Handoff"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If a replica is temporarily unavailable, Cassandra stores a hint on a coordinator node."}),"\n",(0,r.jsx)(n.li,{children:"The hint is replayed to the unavailable node once it comes back online, ensuring eventual consistency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Read Repair"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"During a read, Cassandra compares data across replicas."}),"\n",(0,r.jsx)(n.li,{children:"If inconsistencies are detected, it repairs the data to ensure consistency over time."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gossip Protocol"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Nodes exchange state information using a gossip protocol to maintain cluster awareness and detect failures."}),"\n",(0,r.jsx)(n.li,{children:"Ensures data consistency by facilitating communication between nodes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"trade-offs-in-tunable-consistency",children:(0,r.jsx)(n.strong,{children:"Trade-offs in Tunable Consistency"})}),"\n",(0,r.jsx)(n.p,{children:"The ability to tune consistency provides flexibility, but it comes with trade-offs:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistency vs. Latency"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Higher consistency levels (e.g., ALL, QUORUM) increase latency as more replicas must respond."}),"\n",(0,r.jsx)(n.li,{children:"Lower consistency levels (e.g., ONE, ANY) reduce latency but risk serving stale data."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Availability vs. Consistency"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In scenarios with node failures, lower consistency levels prioritize availability."}),"\n",(0,r.jsx)(n.li,{children:"Higher consistency levels may fail if not enough replicas are available."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Performance Impact"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Higher consistency levels increase coordination overhead and reduce throughput."}),"\n",(0,r.jsx)(n.li,{children:"Lower consistency levels maximize performance but at the cost of potential inconsistencies."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-and-best-practices",children:(0,r.jsx)(n.strong,{children:"Use Cases and Best Practices"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Cases for Different Consistency Levels"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ONE"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use for non-critical applications where latency is more important than consistency."}),"\n",(0,r.jsx)(n.li,{children:"Example: Logging or real-time analytics."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"QUORUM"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use for applications requiring a balance of consistency and availability."}),"\n",(0,r.jsx)(n.li,{children:"Example: E-commerce transactions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ALL"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use for systems where consistency is critical and downtime is acceptable."}),"\n",(0,r.jsx)(n.li,{children:"Example: Financial systems or ledgers."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best Practices"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Align the replication factor with the required consistency level for your use case."}),"\n",(0,r.jsx)(n.li,{children:"Use LOCAL_QUORUM for multi-data center setups to minimize cross-data center latency."}),"\n",(0,r.jsx)(n.li,{children:"Monitor latency and availability trade-offs when selecting consistency levels."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"conclusion",children:(0,r.jsx)(n.strong,{children:"Conclusion"})}),"\n",(0,r.jsx)(n.p,{children:"Tunable consistency is a powerful feature of Cassandra, enabling developers to fine-tune the trade-offs between consistency, availability, and performance for their specific workloads. By understanding and leveraging consistency levels, replication factors, and related mechanisms, you can design resilient, scalable systems that meet your application\u2019s needs."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);