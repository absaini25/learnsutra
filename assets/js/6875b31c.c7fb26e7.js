"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[408],{9741:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Dynamic Programming/Questions/maximal-square","title":"Maximal square in a matrix","description":"Given an\xa0m x n\xa0binary\xa0matrix\xa0filled with\xa00\'s and\xa01\'s,\xa0find the largest square containing only\xa01\'s\xa0and return its area.","source":"@site/docs/Dynamic Programming/Questions/maximal-square.md","sourceDirName":"Dynamic Programming/Questions","slug":"/Dynamic Programming/Questions/maximal-square","permalink":"/docs/Dynamic Programming/Questions/maximal-square","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/docs/Dynamic Programming/Questions/maximal-square.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Longest common subsequence","permalink":"/docs/Dynamic Programming/Questions/longest-common-subsequence"},"next":{"title":"Maximum Score from Performing Multiplication Operations","permalink":"/docs/Dynamic Programming/Questions/maximum-score-from-mul-ops"}}');var t=i(4848),a=i(8453);const s={},o="Maximal square in a matrix",l={},c=[{value:"Solution",id:"solution",level:3},{value:"Python Code with Comments:",id:"python-code-with-comments",level:3},{value:"Java Code:",id:"java-code",level:3},{value:"<strong>Explanation of the Java Code:</strong>",id:"explanation-of-the-java-code",level:3},{value:"<strong>Key Differences Between Python and Java Approaches</strong>:",id:"key-differences-between-python-and-java-approaches",level:3},{value:"<strong>Python Approach:</strong>",id:"python-approach",level:3},{value:"<strong>Java Approach:</strong>",id:"java-approach",level:3},{value:"<strong>Optimization Possibility (Java)</strong>:",id:"optimization-possibility-java",level:3},{value:"Comparison:",id:"comparison",level:3}];function h(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"maximal-square-in-a-matrix",children:"Maximal square in a matrix"})}),"\n",(0,t.jsxs)(n.p,{children:["Given an\xa0",(0,t.jsx)(n.code,{children:"m x n"}),"\xa0binary\xa0",(0,t.jsx)(n.code,{children:"matrix"}),"\xa0filled with\xa0",(0,t.jsx)(n.code,{children:"0"}),"'s and\xa0",(0,t.jsx)(n.code,{children:"1"}),"'s,\xa0",(0,t.jsx)(n.em,{children:"find the largest square containing only"}),"\xa0",(0,t.jsx)(n.code,{children:"1"}),"'s\xa0",(0,t.jsx)(n.em,{children:"and return its area"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example 1:"}),"\n",(0,t.jsx)(n.p,{children:'Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\nOutput: 4'}),"\n",(0,t.jsx)(n.p,{children:"Example 2:"}),"\n",(0,t.jsx)(n.p,{children:'Input: matrix = [["0","1"],["1","0"]]\nOutput: 1'}),"\n",(0,t.jsx)(n.p,{children:"Example 3:"}),"\n",(0,t.jsx)(n.p,{children:'Input: matrix = [["0"]]\nOutput: 0'}),"\n",(0,t.jsx)(n.p,{children:"Constraints:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"m == matrix.length"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"n == matrix[i].length"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"1 <= m, n <= 300"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"matrix[i][j]"}),"\xa0is\xa0",(0,t.jsx)(n.code,{children:"'0'"}),"\xa0or\xa0",(0,t.jsx)(n.code,{children:"'1'"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s the code with proper comments and its equivalent Java implementation:"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"python-code-with-comments",children:"Python Code with Comments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from functools import cache\nfrom typing import List\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        # Initialize the maximum length of a square and dimensions of the matrix\n        maxLen, m, n = 0, len(matrix), len(matrix[0])\n        \n        @cache  # Cache results for overlapping subproblems\n        def maxSquareAtIndex(i: int, j: int) -> int:\n            """\n            Recursive function to compute the largest square with bottom-right corner at (i, j).\n            Returns the side length of the square.\n            """\n            nonlocal maxLen  # Allows us to update the maxLen variable from the outer scope\n            \n            # Base case: Out of bounds\n            if i >= m or j >= n:\n                return 0\n            \n            # If the cell is \'0\', no square can end here\n            if matrix[i][j] == \'0\':\n                return 0\n            \n            # Recursively compute the side length of the largest square at the bottom,\n            # right, and bottom-right neighbors\n            maxLenAtIdx = min(\n                maxSquareAtIndex(i + 1, j),       # Square ending below\n                maxSquareAtIndex(i, j + 1),       # Square ending to the right\n                maxSquareAtIndex(i + 1, j + 1)    # Square ending diagonally\n            ) + 1  # Add 1 for the current cell\n            \n            # Update the global maximum square length\n            maxLen = max(maxLen, maxLenAtIdx)\n            return maxLenAtIdx\n        \n        # Start the recursion for each cell, ensuring all possible squares are considered\n        for i in range(m - 1, -1, -1):  # Loop over rows in reverse\n            for j in range(n - 1, -1, -1):  # Loop over columns in reverse\n                maxSquareAtIndex(i, j)\n        \n        # Return the area of the largest square\n        return maxLen * maxLen\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"java-code",children:"Java Code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.Arrays;\n\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        int m = matrix.length;    // Number of rows\n        int n = matrix[0].length; // Number of columns\n        int maxLen = 0;           // Maximum length of a square found\n        \n        // Create a DP table to store the side length of the largest square ending at (i, j)\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Iterate through the matrix\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // If the cell contains '1', compute the largest square ending here\n                if (matrix[i - 1][j - 1] == '1') {\n                    dp[i][j] = Math.min(\n                        Math.min(dp[i - 1][j], dp[i][j - 1]), // Top and left cells\n                        dp[i - 1][j - 1]                     // Top-left diagonal cell\n                    ) + 1;\n                    \n                    // Update the global maximum square length\n                    maxLen = Math.max(maxLen, dp[i][j]);\n                }\n            }\n        }\n        \n        // Return the area of the largest square\n        return maxLen * maxLen;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"explanation-of-the-java-code",children:(0,t.jsx)(n.strong,{children:"Explanation of the Java Code:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"dp"})," Array"]}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"dp[i][j]"})," represents the side length of the largest square whose bottom-right corner is at ",(0,t.jsx)(n.code,{children:"(i-1, j-1)"})," in the matrix."]}),"\n",(0,t.jsxs)(n.li,{children:["Use a ",(0,t.jsx)(n.code,{children:"(m+1)x(n+1)"})," array to avoid edge cases for boundary conditions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Matrix Traversal"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Traverse the matrix row by row and column by column. For each cell containing ",(0,t.jsx)(n.code,{children:"'1'"}),", calculate the size of the square ending at that cell using the formula:\n[\ndp[i][j] = \\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n]"]}),"\n",(0,t.jsxs)(n.li,{children:["Update the ",(0,t.jsx)(n.code,{children:"maxLen"})," whenever a larger square is found."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Return Area"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The area of the largest square is the square of ",(0,t.jsx)(n.code,{children:"maxLen"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"key-differences-between-python-and-java-approaches",children:[(0,t.jsx)(n.strong,{children:"Key Differences Between Python and Java Approaches"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python"})," uses recursion with memoization (",(0,t.jsx)(n.code,{children:"@cache"}),"), while Java uses an iterative bottom-up DP approach with a 2D array."]}),"\n",(0,t.jsx)(n.li,{children:"In Python, memoization avoids recomputation, while in Java, dynamic programming ensures all subproblems are solved iteratively."}),"\n",(0,t.jsx)(n.li,{children:"Both approaches achieve the same time complexity of (O(m \\times n))."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"space complexity"})," differs between the ",(0,t.jsx)(n.strong,{children:"Python recursive approach with memoization"})," and the ",(0,t.jsx)(n.strong,{children:"Java iterative approach with dynamic programming (DP)"}),":"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"python-approach",children:(0,t.jsx)(n.strong,{children:"Python Approach:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recursion Depth:"})," The recursion stack can go up to (O(m + n)) in the worst case (where (m) is the number of rows and (n) is the number of columns), as the recursion explores the matrix diagonally."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memoization Cache:"})," The cache stores results for each unique cell ((i, j)), requiring (O(m \\times n)) space."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Overall Space Complexity: (O(m \\times n)) (for the cache) + (O(m + n)) (for the recursion stack) = (O(m \\times n))"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"java-approach",children:(0,t.jsx)(n.strong,{children:"Java Approach:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DP Table:"})," The ",(0,t.jsx)(n.code,{children:"dp"})," array requires (O(m \\times n)) space to store the maximum square length for each cell."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Recursion Stack:"})," The iterative nature avoids additional stack usage."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Overall Space Complexity: (O(m \\times n))."})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"optimization-possibility-java",children:[(0,t.jsx)(n.strong,{children:"Optimization Possibility (Java)"}),":"]}),"\n",(0,t.jsxs)(n.p,{children:["In the Java approach, the ",(0,t.jsx)(n.code,{children:"dp"})," array can be optimized to a ",(0,t.jsx)(n.strong,{children:"1D array of size (n+1)"})," because the calculation of ",(0,t.jsx)(n.code,{children:"dp[i][j]"})," only depends on the current row and the previous row. This reduces the space complexity to:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Optimized Java Space Complexity: (O(n))."})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"comparison",children:"Comparison:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Approach"}),(0,t.jsx)(n.th,{children:"Space Complexity"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Python (Recursive + Cache)"}),(0,t.jsx)(n.td,{children:"(O(m \\times n))"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Java (Iterative with 2D DP)"}),(0,t.jsx)(n.td,{children:"(O(m \\times n))"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Java (Iterative with 1D DP)"}),(0,t.jsx)(n.td,{children:"(O(n))"})]})]})]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);