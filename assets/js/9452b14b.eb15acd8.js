"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[8808],{4632:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Distributed Systems Nuances/distributed-locking","title":"Distributed locking via Redis","description":"Vanilla way","source":"@site/system-design/Distributed Systems Nuances/distributed-locking.md","sourceDirName":"Distributed Systems Nuances","slug":"/Distributed Systems Nuances/distributed-locking","permalink":"/system-design/Distributed Systems Nuances/distributed-locking","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/edit/main/system-design/Distributed Systems Nuances/distributed-locking.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Building a Scalable Model for Nested Comments","permalink":"/system-design/Designing Nested Comments/"},"next":{"title":"Cassandra: Deep Dive","permalink":"/system-design/Technology Deep Dives/cassandra"}}');var l=i(4848),t=i(8453);const r={},a="Distributed locking via Redis",o={},c=[{value:"Vanilla way",id:"vanilla-way",level:2},{value:"Using Redlock",id:"using-redlock",level:2},{value:"1. <strong>Resilience to Single Point of Failure</strong>",id:"1-resilience-to-single-point-of-failure",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock",level:4},{value:"Redlock:",id:"redlock",level:4},{value:"2. <strong>Reduced Risk of Split-Brain</strong>",id:"2-reduced-risk-of-split-brain",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock-1",level:4},{value:"Redlock:",id:"redlock-1",level:4},{value:"3. <strong>Improved Clock Drift Tolerance</strong>",id:"3-improved-clock-drift-tolerance",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock-2",level:4},{value:"Redlock:",id:"redlock-2",level:4},{value:"4. <strong>Atomic Lock Acquisition</strong>",id:"4-atomic-lock-acquisition",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock-3",level:4},{value:"Redlock:",id:"redlock-3",level:4},{value:"5. <strong>Minimized Dependency on a Single Redis Instance</strong>",id:"5-minimized-dependency-on-a-single-redis-instance",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock-4",level:4},{value:"Redlock:",id:"redlock-4",level:4},{value:"6. <strong>Built-in Safety Features</strong>",id:"6-built-in-safety-features",level:3},{value:"Vanilla Redis Lock:",id:"vanilla-redis-lock-5",level:4},{value:"Redlock:",id:"redlock-5",level:4},{value:"Caveats of Redlock",id:"caveats-of-redlock",level:3},{value:"Martin Kleppman&#39;s concerns",id:"martin-kleppmans-concerns",level:2},{value:"1. <strong>Safety Guarantees</strong>",id:"1-safety-guarantees",level:3},{value:"2. <strong>Network Partitions</strong>",id:"2-network-partitions",level:3},{value:"3. <strong>Use Cases and Assumptions</strong>",id:"3-use-cases-and-assumptions",level:3},{value:"Summary of Views",id:"summary-of-views",level:3}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.header,{children:(0,l.jsx)(s.h1,{id:"distributed-locking-via-redis",children:"Distributed locking via Redis"})}),"\n",(0,l.jsx)(s.h2,{id:"vanilla-way",children:"Vanilla way"}),"\n",(0,l.jsx)(s.h2,{id:"using-redlock",children:"Using Redlock"}),"\n",(0,l.jsxs)(s.p,{children:["Redlock improves on a ",(0,l.jsx)(s.strong,{children:"vanilla Redis-based locking mechanism"})," by addressing several key issues related to fault tolerance and correctness in distributed systems. Here\u2019s how Redlock is better:"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"1-resilience-to-single-point-of-failure",children:["1. ",(0,l.jsx)(s.strong,{children:"Resilience to Single Point of Failure"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Relies on a single Redis instance to store the lock. If that instance fails, the lock's state is lost, and any process relying on it cannot safely determine the lock's status."}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Uses ",(0,l.jsx)(s.strong,{children:"multiple Redis instances"})," (typically 5, but configurable) across different nodes. A lock is acquired only if a majority of instances (e.g., 3 out of 5) agree that the lock is granted."]}),"\n",(0,l.jsx)(s.li,{children:"This quorum-based approach ensures that even if a minority of Redis instances fail, the lock mechanism remains operational."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"2-reduced-risk-of-split-brain",children:["2. ",(0,l.jsx)(s.strong,{children:"Reduced Risk of Split-Brain"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock-1",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:'In the event of network partitions or Redis instance failures, there\u2019s a higher chance of multiple processes acquiring the same lock (a "split-brain" situation).'}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock-1",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"By requiring a quorum (majority) of Redis nodes to acquire or release a lock, Redlock minimizes the chance of two processes thinking they hold the same lock simultaneously."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"3-improved-clock-drift-tolerance",children:["3. ",(0,l.jsx)(s.strong,{children:"Improved Clock Drift Tolerance"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock-2",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Relies heavily on the expiration time of a single Redis instance. If a server clock drifts (or the Redis server has performance delays), the lock expiration may not behave as expected."}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock-2",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Distributes the lock acquisition and expiration decision across multiple instances, making it less sensitive to timing issues on a single node."}),"\n",(0,l.jsx)(s.li,{children:"The use of timestamps during lock acquisition helps ensure a process has a valid claim on the lock."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"4-atomic-lock-acquisition",children:["4. ",(0,l.jsx)(s.strong,{children:"Atomic Lock Acquisition"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock-3",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Typically implemented using ",(0,l.jsx)(s.code,{children:"SETNX"})," and ",(0,l.jsx)(s.code,{children:"EXPIRE"}),' commands. If these commands are not atomic (or are executed separately), there\'s a chance of inconsistency, such as failing to set an expiration time, leading to a "stuck lock."']}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock-3",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Ensures atomicity by using a carefully timed and consistent mechanism across multiple Redis instances. Locks are granted only if they are acquired within a specific time window on the majority of instances."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"5-minimized-dependency-on-a-single-redis-instance",children:["5. ",(0,l.jsx)(s.strong,{children:"Minimized Dependency on a Single Redis Instance"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock-4",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Highly dependent on the availability, performance, and reliability of one Redis instance. If this instance becomes unavailable, the locking mechanism fails entirely."}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock-4",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Spreads the lock across multiple Redis instances, reducing the dependency on any single node. Even with a partial outage, the system can still operate."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"6-built-in-safety-features",children:["6. ",(0,l.jsx)(s.strong,{children:"Built-in Safety Features"})]}),"\n",(0,l.jsx)(s.h4,{id:"vanilla-redis-lock-5",children:"Vanilla Redis Lock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Lacks advanced failure recovery mechanisms. For example, if a lock holder crashes, it can be difficult to detect and recover the lock without custom logic."}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"redlock-5",children:"Redlock:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Includes safeguards such as:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Ensuring the lock expiration time is carefully chosen to avoid lingering locks."}),"\n",(0,l.jsx)(s.li,{children:"Recovering from partial failures (e.g., if a lock is acquired on some Redis nodes but not all)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"caveats-of-redlock",children:"Caveats of Redlock"}),"\n",(0,l.jsxs)(s.p,{children:["While Redlock is better than vanilla implementations, it still has its ",(0,l.jsx)(s.strong,{children:"limitations"}),":"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Timing Sensitivity"}),": Redlock relies on accurate clock synchronization across Redis instances."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Not Consensus-Based"}),": Unlike algorithms like Paxos or Raft, Redlock does not offer the same level of theoretical guarantees in highly fault-tolerant distributed systems."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{id:"martin-kleppmans-concerns",children:"Martin Kleppman's concerns"}),"\n",(0,l.jsxs)(s.p,{children:["The key point of contention between Martin Kleppmann and the authors of ",(0,l.jsx)(s.strong,{children:"Redlock"})," (a distributed locking algorithm implemented in Redis) lies in whether Redlock meets the safety guarantees required for distributed systems. This debate focuses on the algorithm's ability to function correctly under certain conditions, particularly in the presence of network partitions and failures."]}),"\n",(0,l.jsx)(s.p,{children:"Here are the major points of disagreement:"}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"1-safety-guarantees",children:["1. ",(0,l.jsx)(s.strong,{children:"Safety Guarantees"})]}),"\n",(0,l.jsxs)(s.p,{children:["Martin Kleppmann's criticism centers around whether Redlock satisfies the ",(0,l.jsx)(s.strong,{children:"mutual exclusion"})," property in a distributed environment. In distributed systems, mutual exclusion ensures that at most one process can hold a lock at any time. Kleppmann argues that Redlock may fail to guarantee this due to:"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Clock Skew and Timing Assumptions"}),": Redlock assumes that the system clocks on different nodes are reasonably synchronized. However, in a distributed system, clocks can drift, and this drift can cause inconsistencies, such as locks expiring too early or late."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Race Conditions on Lock Renewal"}),": Redlock relies on clients renewing locks within a certain time frame. If a process with an expired lock doesn't release it promptly, another process may acquire it, leading to two processes believing they hold the lock simultaneously."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:["Kleppmann compares Redlock to more rigorously proven algorithms, like those based on ",(0,l.jsx)(s.strong,{children:"Paxos"})," or ",(0,l.jsx)(s.strong,{children:"Raft"}),", which are explicitly designed to handle such failure scenarios."]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"2-network-partitions",children:["2. ",(0,l.jsx)(s.strong,{children:"Network Partitions"})]}),"\n",(0,l.jsxs)(s.p,{children:["Kleppmann emphasizes that during a ",(0,l.jsx)(s.strong,{children:"network partition"}),", where parts of the network are isolated from each other:"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Redlock may allow multiple nodes to acquire the same lock independently because the system cannot reconcile conflicting states between partitions."}),"\n",(0,l.jsx)(s.li,{children:"In cases where a process releases a lock after a partition ends, the distributed state may still violate mutual exclusion."}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"The authors of Redlock argue that these situations are unlikely in practice and that Redis is not designed to be a strict consensus system but rather a practical one for certain classes of applications."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsxs)(s.h3,{id:"3-use-cases-and-assumptions",children:["3. ",(0,l.jsx)(s.strong,{children:"Use Cases and Assumptions"})]}),"\n",(0,l.jsx)(s.p,{children:"The debate also highlights the intended use cases for distributed locks:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Redlock's Authors"}),": Argue that Redlock is sufficient for many real-world applications that tolerate some level of risk. They highlight its simplicity and practicality compared to consensus-based algorithms."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Martin Kleppmann"}),": Advocates for using consensus algorithms (like those used in ",(0,l.jsx)(s.strong,{children:"ZooKeeper"})," or ",(0,l.jsx)(s.strong,{children:"Etcd"}),") if strict guarantees of correctness and fault tolerance are required. He believes Redlock is unsuitable for scenarios where safety is critical (e.g., financial systems, resource allocation)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"summary-of-views",children:"Summary of Views"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Martin Kleppmann"}),": Redlock does not meet the stringent safety guarantees needed for distributed locking in fault-tolerant systems."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Redlock Authors"}),": Redlock is pragmatic and fits many real-world applications where strict consensus-based algorithms might be overkill."]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:["This debate reflects a broader trade-off between ",(0,l.jsx)(s.strong,{children:"simplicity and performance"})," versus ",(0,l.jsx)(s.strong,{children:"strict correctness"})," in distributed systems."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>r,x:()=>a});var n=i(6540);const l={},t=n.createContext(l);function r(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);