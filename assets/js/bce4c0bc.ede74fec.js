"use strict";(self.webpackChunklearnsutra=self.webpackChunklearnsutra||[]).push([[3357],{2010:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Stack/Monotonic Stack/previous-larger-or-smaller-element","title":"Previous larger/smaller element","description":"The Previous Smaller Element (PSE) and Previous Larger Element (PLE) problems are similar to Next Smaller Element (NSE) and Next Larger Element (NLE), but instead of looking for the first element to the right, we look for the first element to the left of each index.","source":"@site/docs/Stack/Monotonic Stack/previous-larger-or-smaller-element.md","sourceDirName":"Stack/Monotonic Stack","slug":"/Stack/Monotonic Stack/previous-larger-or-smaller-element","permalink":"/docs/Stack/Monotonic Stack/previous-larger-or-smaller-element","draft":false,"unlisted":false,"editUrl":"https://github.com/absaini25/learnsutra/docs/Stack/Monotonic Stack/previous-larger-or-smaller-element.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Next Smaller/Larger Element","permalink":"/docs/Stack/Monotonic Stack/next-larger-or-smaller-element"},"next":{"title":"Iterative binary tree traversal","permalink":"/docs/Tree/iterative-binary-tree-traversal"}}');var l=r(4848),s=r(8453);const i={},o="Previous larger/smaller element",a={},c=[{value:"<strong>Previous Smaller Element (PSE)</strong>",id:"previous-smaller-element-pse",level:3},{value:"Goal:",id:"goal",level:4},{value:"Algorithm (Monotonic Stack Approach):",id:"algorithm-monotonic-stack-approach",level:4},{value:"Example (PSE):",id:"example-pse",level:4},{value:"<strong>Previous Larger Element (PLE)</strong>",id:"previous-larger-element-ple",level:3},{value:"Goal:",id:"goal-1",level:4},{value:"Algorithm (Monotonic Stack Approach):",id:"algorithm-monotonic-stack-approach-1",level:4},{value:"Example (PLE):",id:"example-ple",level:4},{value:"<strong>Key Observations</strong>",id:"key-observations",level:3},{value:"<strong>Code Implementation</strong>",id:"code-implementation",level:3},{value:"Previous Smaller Element (PSE)",id:"previous-smaller-element-pse-1",level:4},{value:"Previous Larger Element (PLE)",id:"previous-larger-element-ple-1",level:4},{value:"<strong>Applications</strong>",id:"applications",level:3}];function h(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"previous-largersmaller-element",children:"Previous larger/smaller element"})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.strong,{children:"Previous Smaller Element (PSE)"})," and ",(0,l.jsx)(n.strong,{children:"Previous Larger Element (PLE)"})," problems are similar to ",(0,l.jsx)(n.strong,{children:"Next Smaller Element (NSE)"})," and ",(0,l.jsx)(n.strong,{children:"Next Larger Element (NLE)"}),", but instead of looking for the first element to the ",(0,l.jsx)(n.strong,{children:"right"}),", we look for the first element to the ",(0,l.jsx)(n.strong,{children:"left"})," of each index."]}),"\n",(0,l.jsxs)(n.p,{children:["These are also efficiently solved using a ",(0,l.jsx)(n.strong,{children:"monotonic stack"}),", but this time the array is traversed ",(0,l.jsx)(n.strong,{children:"from left to right"}),"."]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"previous-smaller-element-pse",children:(0,l.jsx)(n.strong,{children:"Previous Smaller Element (PSE)"})}),"\n",(0,l.jsx)(n.h4,{id:"goal",children:"Goal:"}),"\n",(0,l.jsx)(n.p,{children:"For each element in the array, find the first smaller element to its left."}),"\n",(0,l.jsx)(n.h4,{id:"algorithm-monotonic-stack-approach",children:"Algorithm (Monotonic Stack Approach):"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Initialize a stack"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The stack will store indices of elements in the array."}),"\n",(0,l.jsxs)(n.li,{children:["It will maintain a ",(0,l.jsx)(n.strong,{children:"monotonic increasing order"})," of element values (from top to bottom)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Iterate through the array from left to right"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["For each element:","\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["While the stack is not empty and the element at the top of the stack is ",(0,l.jsx)(n.strong,{children:"greater than or equal to"})," the current element, ",(0,l.jsx)(n.strong,{children:"pop"})," the stack."]}),"\n",(0,l.jsxs)(n.li,{children:["If the stack is not empty after the above step, the ",(0,l.jsx)(n.strong,{children:"top of the stack"})," points to the ",(0,l.jsx)(n.strong,{children:"previous smaller element"})," for the current element."]}),"\n",(0,l.jsx)(n.li,{children:"Push the current element's index onto the stack."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Result"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"For every element, if no smaller element exists, the result will be (-1)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"example-pse",children:"Example (PSE):"}),"\n",(0,l.jsx)(n.p,{children:"Input: ([4, 2, 1, 5, 3])"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Index"}),(0,l.jsx)(n.th,{children:"Element"}),(0,l.jsx)(n.th,{children:"Stack (Top to Bottom)"}),(0,l.jsx)(n.th,{children:"PSE"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"0"}),(0,l.jsx)(n.td,{children:"4"}),(0,l.jsx)(n.td,{children:"[0]"}),(0,l.jsx)(n.td,{children:"-1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"1"}),(0,l.jsx)(n.td,{children:"2"}),(0,l.jsx)(n.td,{children:"[1]"}),(0,l.jsx)(n.td,{children:"-1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"2"}),(0,l.jsx)(n.td,{children:"1"}),(0,l.jsx)(n.td,{children:"[2]"}),(0,l.jsx)(n.td,{children:"-1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"3"}),(0,l.jsx)(n.td,{children:"5"}),(0,l.jsx)(n.td,{children:"[2, 3]"}),(0,l.jsx)(n.td,{children:"1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"4"}),(0,l.jsx)(n.td,{children:"3"}),(0,l.jsx)(n.td,{children:"[2, 4]"}),(0,l.jsx)(n.td,{children:"1"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"Result: ([-1, -1, -1, 1, 1])"}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"previous-larger-element-ple",children:(0,l.jsx)(n.strong,{children:"Previous Larger Element (PLE)"})}),"\n",(0,l.jsx)(n.h4,{id:"goal-1",children:"Goal:"}),"\n",(0,l.jsx)(n.p,{children:"For each element in the array, find the first larger element to its left."}),"\n",(0,l.jsx)(n.h4,{id:"algorithm-monotonic-stack-approach-1",children:"Algorithm (Monotonic Stack Approach):"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Initialize a stack"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The stack will store indices of elements in the array."}),"\n",(0,l.jsxs)(n.li,{children:["It will maintain a ",(0,l.jsx)(n.strong,{children:"monotonic decreasing order"})," of element values (from top to bottom)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Iterate through the array from left to right"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["For each element:","\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["While the stack is not empty and the element at the top of the stack is ",(0,l.jsx)(n.strong,{children:"less than or equal to"})," the current element, ",(0,l.jsx)(n.strong,{children:"pop"})," the stack."]}),"\n",(0,l.jsxs)(n.li,{children:["If the stack is not empty after the above step, the ",(0,l.jsx)(n.strong,{children:"top of the stack"})," points to the ",(0,l.jsx)(n.strong,{children:"previous larger element"})," for the current element."]}),"\n",(0,l.jsx)(n.li,{children:"Push the current element's index onto the stack."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Result"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"For every element, if no larger element exists, the result will be (-1)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"example-ple",children:"Example (PLE):"}),"\n",(0,l.jsx)(n.p,{children:"Input: ([4, 2, 1, 5, 3])"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Index"}),(0,l.jsx)(n.th,{children:"Element"}),(0,l.jsx)(n.th,{children:"Stack (Top to Bottom)"}),(0,l.jsx)(n.th,{children:"PLE"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"0"}),(0,l.jsx)(n.td,{children:"4"}),(0,l.jsx)(n.td,{children:"[0]"}),(0,l.jsx)(n.td,{children:"-1"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"1"}),(0,l.jsx)(n.td,{children:"2"}),(0,l.jsx)(n.td,{children:"[0, 1]"}),(0,l.jsx)(n.td,{children:"4"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"2"}),(0,l.jsx)(n.td,{children:"1"}),(0,l.jsx)(n.td,{children:"[0, 1, 2]"}),(0,l.jsx)(n.td,{children:"2"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"3"}),(0,l.jsx)(n.td,{children:"5"}),(0,l.jsx)(n.td,{children:"[3]"}),(0,l.jsx)(n.td,{children:"4"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"4"}),(0,l.jsx)(n.td,{children:"3"}),(0,l.jsx)(n.td,{children:"[3, 4]"}),(0,l.jsx)(n.td,{children:"5"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"Result: ([-1, 4, 2, -1, 5])"}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"key-observations",children:(0,l.jsx)(n.strong,{children:"Key Observations"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Stack Property"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"For PSE, the stack ensures the elements in it are smaller than the current element (monotonic increasing stack)."}),"\n",(0,l.jsx)(n.li,{children:"For PLE, the stack ensures the elements in it are larger than the current element (monotonic decreasing stack)."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Efficiency"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Each element is pushed onto and popped from the stack at most once, ensuring (O(n)) time complexity."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Edge Cases"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"If the array is sorted in increasing order, all elements will have (-1) as their PSE."}),"\n",(0,l.jsx)(n.li,{children:"If the array is sorted in decreasing order, all elements will have (-1) as their PLE."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"code-implementation",children:(0,l.jsx)(n.strong,{children:"Code Implementation"})}),"\n",(0,l.jsx)(n.h4,{id:"previous-smaller-element-pse-1",children:"Previous Smaller Element (PSE)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"def previousSmallerElements(arr):\n    n = len(arr)\n    pse = [-1] * n\n    stack = []\n    \n    for i in range(n):  # Traverse from left to right\n        while stack and arr[stack[-1]] >= arr[i]:\n            stack.pop()\n        if stack:\n            pse[i] = arr[stack[-1]]\n        stack.append(i)\n    \n    return pse\n"})}),"\n",(0,l.jsx)(n.h4,{id:"previous-larger-element-ple-1",children:"Previous Larger Element (PLE)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"def previousLargerElements(arr):\n    n = len(arr)\n    ple = [-1] * n\n    stack = []\n    \n    for i in range(n):  # Traverse from left to right\n        while stack and arr[stack[-1]] <= arr[i]:\n            stack.pop()\n        if stack:\n            ple[i] = arr[stack[-1]]\n        stack.append(i)\n    \n    return ple\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"applications",children:(0,l.jsx)(n.strong,{children:"Applications"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Histogram Problems"}),": PSE and NSE are used to compute the width of rectangles in the largest rectangle in a histogram problem."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Stock Span Problems"}),": PLE helps determine the previous higher price for stock analysis."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sliding Window Problems"}),": PSE and NSE provide critical insights for subarray calculations."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const l={},s=t.createContext(l);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);